#! /bin/sh
#
# Globus Job Manager GRD interface script for reporting job status
#
# This script uses information obtained from a file passed as the
# script's argument. This file contains a list of environment variables
# which are set by way of "sourcing" the file from this script. One of
# the evironment variables set as a result of this action is then used
# to obtain the job id for which status is requested. Once the job id
# is determined the GRD qstat command is used to obtain the current
# status of the job. This status is then returned.
#
# The Status field can contain one of the following strings:
#
# string	stands for			Globus context meaning
# --------------------------------------------------------------------
# RUN		Running				ACTIVE
# PEND		Wating to be scheduled		PENDING
# USUSP		Suspended while running 	SUSPENDED
# PSUSP		Suspended while pending 	SUSPENDED
# SSUSP		Suspended by system 		SUSPENDED
# DONE		Completed sucessfully 		DONE
# EXIT		Completed unsuccessfully	FAILED 
# UNKWN		Unknown state			FAILED 
# ZOMBI		Unknown state			FAILED 
# --------------------------------------------------------------------

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-gram-protocol-constants.sh
globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh

qstat=${GLOBUS_GRAM_JOB_MANAGER_QSTAT-qstat}
grep=${GLOBUS_SH_GREP-grep}
awk=${GLOBUS_SH_AWK-awk}
sed=${GLOBUS_SH_SED-sed}


arg_file=$1

# Check for the argument file. If it does not exist
# then return with an error immediately
if [ ! -f $arg_file ] ; then
   echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_BAD_SCRIPT_ARG_FILE
   exit 1
fi

# Source the argument file to set environment variables
# defining all the job arguments
. $arg_file

# If a logfile name has been defined then activate debug mode
if [ $grami_logfile = "/dev/null" ] ; then
    DEBUG_ECHO=:
else
    DEBUG_ECHO=echo
fi

#assumption is that the qstat path will take the form
# /<dir>/<dir>.../<grd_root>/bin/<grd_arch>/qstat
# so parse the command from the end to get the GRD ROOT dir.
#
# from the qsub path, remove the last slash and all that follows it.
# Leaving the directory.  Not all systems have dirname.
grd_dir=`echo $qstat | $sed 's|/[^/][^/]*$||'`

# remove everything up to the last slash.  Leaving the grd arch value.
GRD_ARCH=`echo $grd_dir | $sed 's|.*/||'`

#remove the next 2 subdir (e.g. <bin>/<arch>) leaving the grd_root
grd_dir=`echo $grd_dir | $sed 's|/[^/][^/]*$||'`
GRD_ROOT=`echo $grd_dir | $sed 's|/[^/][^/]*$||'`

export GRD_ROOT
. $GRD_ROOT/default/common/settings.sh

$DEBUG_ECHO "GRD_ROOT=$GRD_ROOT" >> $grami_logfile
$DEBUG_ECHO in gram_script_grd_poll >> $grami_logfile
$DEBUG_ECHO executing qstat with job id $grami_job_id >> $grami_logfile

# Obtain job status from GRD qstat command
qstat_out="`${qstat} 2>>$grami_logfile`"
cc=$?

status=`echo "${qstat_out}" | \
        ${awk} '{print $1, $5}' | \
        ${grep} $grami_job_id | \
        ${awk} '{print $2}'`

$DEBUG_ECHO $qstat status is $cc, output is $status >> $grami_logfile

case $status in
	*q*)  gram_job_state=$GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING;;
	*t*)   gram_job_state=$GLOBUS_GRAM_PROTOCOL_JOB_STATE_ACTIVE;;
	*r*)   gram_job_state=$GLOBUS_GRAM_PROTOCOL_JOB_STATE_ACTIVE;;
	*s*) gram_job_state=$GLOBUS_GRAM_PROTOCOL_JOB_STATE_SUSPENDED;;
	*S*) gram_job_state=$GLOBUS_GRAM_PROTOCOL_JOB_STATE_SUSPENDED;;
	*T*) gram_job_state=$GLOBUS_GRAM_PROTOCOL_JOB_STATE_SUSPENDED;;
	*E*)  gram_job_state=$GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING;;
        "") gram_job_state=$GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE;;
	*) gram_job_state=$GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED;;
esac

# Return appropriate job status

$DEBUG_ECHO "returning success, job state: $gram_job_state" >> $grami_logfile
echo "GRAM_SCRIPT_SUCCESS:$gram_job_state"

$DEBUG_ECHO "exiting gram_script_grd_poll\n\n" >> $grami_logfile

exit
