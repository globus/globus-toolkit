#! /bin/sh -f
###################################################################
# globus-script-<scheduler>-queue script
# --------------------------------------
#
# The purpose of this script is to communicate the queue values and
# current queue entries (jobs) to the globus-gram-scheduler function.
# This function will then compile the information into C structures to 
# present a uniform interface to more easily facilitate multi queue
# analysis.
#
# queue information is output in the form:
#     GRAM_SCRIPT_Q:<gram queue parameter> <local scheduler value>
#
# queue entry information (i.e. jobs) are output in the form:
#     GRAM_SCRIPT_QE:<gram queue entry parameter> <local scheduler job value>
#      
#
###################################################################
# Below is a conversion chart for this scheduler queue's job status
# value to Globus job status value.
#
# The Status field can contain one of the following strings:
#
# string        stands for                      Globus context meaning
# --------------------------------------------------------------------
# C       Completed			DONE
# D       Deferred 			PENDING
# H       User Hold 			PENDING
# I       Idle 				PENDING
# NR      Not Run 			FAILED
# NQ      Not Queued 			PENDING
# P       Pending 			PENDING
# R       Running 			ACTIVE
# RM      Removed 			FAILED?  (program was cancelled)
# RP      Remove Pending 		FAILED?  (program was cancelled)
# S       System Hold 			PENDING
# SH      User Hold and System Hold 	PENDING
# ST      Starting 			PENDING
# V       Vacated 			PENDING? (started but did not complete)
# XP      Reject Pending 		FAILED
#
########

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh


# programs used in this script located by autoconf:
llstatus=${GLOBUS_GRAM_JOB_MANAGER_LLSTATUS-llstatus}
llq=${GLOBUS_GRAM_JOB_MANAGER_LLQ-llq}
grep=${GLOBUS_SH_GREP-grep}
awk=${GLOBUS_SH_AWK-awk}
wc=${GLOBUS_SH_WC-wc}

tmp_file="${local_tmpdir}/globus_tmp_file.$$"

############################################################
#
# GetNodeCount
#
#
# Get free and total nodes from the system
#

GetNodeCount() {
  ${llstatus} > $tmp_file
  FREENODES=`cat $tmp_file | ${grep} "Idle" | ${wc} -l`
  #subtract one for an extra "Idle" count from the heading line
  FREENODES=`expr ${FREENODES} - 1`
  busy=`cat $tmp_file | ${grep} "Busy" | ${wc} -l`
  TOTALNODES=`expr ${FREENODES} + ${busy}`
  rm $tmp_file
} #########################


############################################################
#
# OutputQueueEntry
#
#
# convert scheduler specific information to the standard GRAM queue 
# entry parameters.
#
# format GRAM_SCRIPT_QE:<GRAM parameter> <scheduler value>
#

OutputQueueEntry() {

  # if all required fields have values then output the information
  if [ -n "${clusterid}" ] &&
     [ -n "${owner}" ] &&
     [ -n "${count}" ] &&
     [ -n "${jobstatus}" ] ; then
     echo "GRAM_SCRIPT_QE:startqueueentry"
     echo "GRAM_SCRIPT_QE:localjobid ${clusterid}"
     echo "GRAM_SCRIPT_QE:localusername ${owner}"
     echo "GRAM_SCRIPT_QE:count ${count}"
     echo "GRAM_SCRIPT_QE:status ${jobstatus}"
     echo "GRAM_SCRIPT_QE:endqueueentry"
  fi
  # reset info
  clusterid=""
  owner=""
  jobstatus=""
  count=""
} #########################

################## main section #######################
# Ouput queue values where possible

echo "GRAM_SCRIPT_Q:StartQueue"
GetNodeCount
echo "GRAM_SCRIPT_Q:totalNodes ${TOTALNODES}"
echo "GRAM_SCRIPT_Q:freeNodes ${FREENODES}"
echo "GRAM_SCRIPT_Q:maxtime 0"
echo "GRAM_SCRIPT_Q:maxCPUtime 0"
echo "GRAM_SCRIPT_Q:maxCount 0"
echo "GRAM_SCRIPT_Q:maxRunningJobs 0"
echo "GRAM_SCRIPT_Q:maxJobsInQueue 0"
echo "GRAM_SCRIPT_Q:maxTotalMemory 0"
echo "GRAM_SCRIPT_Q:maxSingleMemory 0"
echo "GRAM_SCRIPT_Q:whenActive 0"
echo "GRAM_SCRIPT_Q:status 0"
echo "GRAM_SCRIPT_Q:dispatchType batch"
#echo "GRAM_SCRIPT_Q:priority 0"
#echo "GRAM_SCRIPT_Q:allowedUser user1"
#echo "GRAM_SCRIPT_Q:allowedUser user2"
#echo "GRAM_SCRIPT_Q:jobWait 0"
#echo "GRAM_SCRIPT_Q:schedulerSpecific"
echo "GRAM_SCRIPT_Q:notlistingjobentries"
echo "GRAM_SCRIPT_Q:EndQueue"

# loop through all queue entries.  For each entry grab values and call
# function OutputQueueEntry
#
#llq | while read entry ; do
#   
#  write code to parse queue entries.  For each call OutputQueueEntry
#  Note: in OutputQueueEntry there is a minimum set of required fields
#
#done

#used for debugging
#cat ~./llq_output > "${tmp_file}"

"${llq}" > "${tmp_file}"

exec < "${tmp_file}"

while [ 1 ] ; do

   read entry

   if [ $? != 0 ] ; then
      break
   fi

   set -- ${entry}

   if [ "$1x" = "x" ] ||
      [ "$2x" = "x" ] ||
      [ "$3x" = "x" ] ; then
      continue
   fi

   if [ "$1" = "--" ] && [ "$2" = "Submittor:" ] ; then
      continue
   fi

   case "$1" in

     MyType )
        if [ ${arch_os_match} -eq 1 ] ; then
            outputQueueEntry
        fi
        arch_os_match=0
        ;;

     JobStatus )
        case $3 in
           0 ) jobstatus=PENDING ;;
           1 ) jobstatus=PENDING ;;
           2 ) jobstatus=ACTIVE ;;
           3 ) jobstatus=FAILED ;;
           4 ) jobstatus=DONE ;;
           5 ) jobstatus=SUSPENDED ;;
           6 ) jobstatus=FAILED ;;
           * ) jobstatus=UNKNOWN ;;
        esac ;;

      ClusterId ) clusterid=$3 ;;

      ProcId )  procid=$3 ;;

      MaxHosts )  count=$3 ;;

      Owner ) owner=`echo $3 | ${awk} '{print substr($1,2,length($1)-2); }'` ;;

      Requirements )
          test_os=`echo "${entry}" | ${grep} -i "OpSys == \"${condor_os}\""`
          test_arch=`echo "${entry}" | ${grep} -i "Arch == \"${condor_arch}\""`
          if [ -n "${test_os}" ] &&
             [ -n "${test_arch}" ] ; then
             arch_os_match=1
          fi ;;

      * ) continue ;;

   esac
       
done

if [ ${arch_os_match} -eq 1 ] ; then
    outputQueueEntry
fi

rm -f ${tmp_file}
