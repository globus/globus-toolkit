#! /bin/sh -f

###################################################################
# globus-script-<scheduler>-queue script
# --------------------------------------
#
# The purpose of this script is to communicate the queue values and
# current queue entries (jobs) to the globus-gram-scheduler function.
# This function will then compile the information into C structures to 
# present a uniform interface to more easily facilitate multi queue
# analysis.
#
# queue information is output in the form:
#     GRAM_SCRIPT_Q:<gram queue parameter> <local scheduler value>
#
# queue entry information (i.e. jobs) are output in the form:
#     GRAM_SCRIPT_QE:<gram queue entry parameter> <local scheduler job value>
#      
#
###################################################################
# Below is a conversion chart for this scheduler queue's job status
# value to Globus job status value.
#
# The Status field can contain one of the following strings:
#
# string        stands for                      Globus context meaning
# --------------------------------------------------------------------
#
#

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh


# programs used in this script located by autoconf:
showpart=${GLOBUS_GRAM_JOB_MANAGER_SHOWPART-showpart}
ps=${GLOBUS_GRAM_JOB_MANAGER_PS-ps}
awk=${GLOBUS_SH_AWK-awk}
########


############################################################
#
# GetNodeCount
#
#
# Get free and total nodes from the system
#
#

GetNodeCount() {

   if [ -x "${showpart}" ]; then
       nodeline=`${showpart} -f | ${sed} -n 2p`
       totalnodes=`echo $nodeline | ${awk} '{print $4}'`
       freenodes=`echo $nodeline | ${awk} '{print $5}'`
   fi

   if [ -z "$TOTALNODES" ]; then
       TOTALNODES=0
   fi
   if [ -z "$FREENODES" ]; then
       FREENODES=0
   fi

} #########################


############################################################
#
# OutputQueueEntry
#
#
# convert scheduler specific information to the standard GRAM queue 
# entry parameters.
#
# format GRAM_SCRIPT_QE:<GRAM parameter> <scheduler value>
#

OutputQueueEntry() {

  # if all required fields have values then output the information
  if [ -n "${clusterid}" ] &&
     [ -n "${owner}" ] &&
     [ -n "${count}" ] &&
     [ -n "${jobstatus}" ] ; then
     echo "GRAM_SCRIPT_QE:startqueueentry"
     echo "GRAM_SCRIPT_QE:localjobid ${clusterid}"
     echo "GRAM_SCRIPT_QE:localusername ${owner}"
     echo "GRAM_SCRIPT_QE:count ${count}"
     echo "GRAM_SCRIPT_QE:status ${jobstatus}"
     echo "GRAM_SCRIPT_QE:endqueueentry"
  fi
  # reset info
  clusterid=""
  owner=""
  jobstatus=""
  count=""

} #########################


################## main section #######################
# Ouput queue values where possible

echo "GRAM_SCRIPT_Q:StartQueue"
GetNodeCount
echo "GRAM_SCRIPT_Q:totalNodes ${TOTALNODES}"
echo "GRAM_SCRIPT_Q:freeNodes ${FREENODES}"
echo "GRAM_SCRIPT_Q:maxtime 0"
echo "GRAM_SCRIPT_Q:maxCPUtime 0"
echo "GRAM_SCRIPT_Q:maxCount 0"
echo "GRAM_SCRIPT_Q:maxRunningJobs 0"
echo "GRAM_SCRIPT_Q:maxJobsInQueue 0"
echo "GRAM_SCRIPT_Q:maxTotalMemory 0"
echo "GRAM_SCRIPT_Q:maxSingleMemory 0"
echo "GRAM_SCRIPT_Q:whenActive 0"
echo "GRAM_SCRIPT_Q:status 0"
echo "GRAM_SCRIPT_Q:dispatchType batch"
#echo "GRAM_SCRIPT_Q:priority 0"
#echo "GRAM_SCRIPT_Q:allowedUser user1"
#echo "GRAM_SCRIPT_Q:allowedUser user2"
#echo "GRAM_SCRIPT_Q:jobWait 0"
#echo "GRAM_SCRIPT_Q:schedulerSpecific"
echo "GRAM_SCRIPT_Q:notlistingjobentries"
echo "GRAM_SCRIPT_Q:EndQueue"

# loop through all queue entries.  For each entry grab values and call
# function OutputQueueEntry
#
#${ps} -ef | while read entry ; do
#   
#  write code to parse queue entries.  For each call OutputQueueEntry
#  Note: in OutputQueueEntry there is a minimum set of required fields
#
#done
