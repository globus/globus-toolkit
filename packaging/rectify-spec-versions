#!/usr/bin/perl

use Getopt::Long;
use POSIX;
use XML::Parser;
use User::pwent;
use Sys::Hostname;
use Pod::Usage;
use Data::Dumper;
use strict;

my $gptfile;
my $setupfile;
my $email;
my $nodoc;
my $help;
my $packagelistfile;
my $verbose;
my $gtrelease = undef;
my $gtreleaseuri = undef;
my $changelog = undef;
my $prompt_for_changelog = undef;
my $cvs_changelog = undef;
my $fullname = undef;
my $bumprelease = undef;
my $new_release = undef;

GetOptions('gptfile=s' => \$gptfile,
           'packagelistfile=s' => \$packagelistfile,
           'email=s' => \$email,
           'verbose' => \$verbose,
           'release=s' => \$gtrelease,
           'changelog=s' => \$changelog,
           'prompt-for-changelog' => \$prompt_for_changelog,
           'cvs-changelog' => \$cvs_changelog,
           'fullname=s' => \$fullname,
           'bumprelease' => \$bumprelease,
           'help' => \$help);

Pod::Usage::pod2usage() if defined $help;

setlocale(LC_TIME, 'C');

if ($gtrelease)
{
    my ($major, $minor, $micro) = split(/\./, $gtrelease);
    $gtreleaseuri="http://www.globus.org/ftppub/gt$major/$major.$minor/$gtrelease/packages/src/";
}
my $login = getlogin || getpwuid($<);
my $pw = getpwnam($login);
my ($location, $phone);
my $host = hostname;
($fullname, $location, $phone) = split(/,/, $pw->gecos) if (!$fullname);
$email = "$login\@$host" unless defined $email;

my @packagelist;
if (!(defined $gptfile))
{
    if ($packagelistfile ne '')
    {
        open(PKG, "$packagelistfile");
    }
    else
    {
        open(PKG, "etc/package-list-5.1.0");
    }
    while ( <PKG> )
    {
        my ($pkg, $subdir, $pnb, $pkgtag) = split(' ', $_);
        next if ($pkg =~ m/^#/ || $pkg =~ m/^$/);
        #print $subdir."\n";
        next if ($pkg =~ m/openssh/);
        push(@packagelist, "source-trees/".$subdir."\/pkgdata\/pkg_data_src.gpt.in");
    }
}
else
{
    push(@packagelist, $gptfile);
}
#print Dumper @packagelist;

foreach my $gptmetadata (@packagelist)
{
my $parser = new XML::Parser(Style => 'Objects', Pkg => 'GPT');

my %srcdeps;
my %depsuntyped;
my %setupdeps;

my $gptdoc = $parser->parsefile($gptmetadata);

my $gptmeta = $gptdoc->[0];
my $gptname = $gptmeta->{Name};

my $gptagingver = (grep {$_->isa('GPT::Aging_Version')} @{$gptmeta->{Kids}})[0];
my $gptmajorver = $gptagingver->{Major};
my $gptminorver = $gptagingver->{Minor};

my $gptdesc =  (grep {$_->isa('GPT::Description')} @{$gptmeta->{Kids}})[0];
my $description = $gptdesc->{Kids}->[0]->{Text};
$description =~ s!^\s+|\s+$!!g;

my $srcpkg = (grep {$_->isa('GPT::src_pkg')} @{$gptmeta->{Kids}})[0];
for my $srcdep (grep {$_->isa('GPT::Source_Dependencies')} @{$srcpkg->{Kids}})
{
    my $type = $srcdep->{Type};
    $srcdeps{$type} = {} unless defined $srcdeps{$type};
    for my $dep (grep {$_->isa('GPT::Dependency')} @{$srcdep->{Kids}})
    {
        my $depname = $dep->{Name};
        my $deppkg = $dep->{Package} if defined $dep->{Package};
        $depname = $depname . "-progs" if ($deppkg eq "pgm");
        $depname = $depname . "-doc" if ($deppkg eq "doc");
        $depname =~ tr/_/-/;
        my $baz = (grep {$_->isa('GPT::Version')} @{$dep->{Kids}})[0];
        my @depver_elements = (grep {$_->isa('GPT::Simple_Version')}
            @{$baz->{Kids}});

        for my $depver_element (@depver_elements)
        {
            # Handle the case where multiple Simple_Version elements live
            # in the Dependency element. For now, we choose the largest number
            # (We see this in the myproxy spec)
            my $depver = $depver_element->{Major};
            $srcdeps{$type}{$depname} = $depver
                unless (defined $srcdeps{$type}{$depname}
                        and $srcdeps{$type}{$depname} >= $depver);
            $depsuntyped{$depname} = $depver
                unless (defined $depsuntyped{$depname}
                        and $depsuntyped{$depname} >= $depver);
        }
    }
}
#print Dumper %depsuntyped;
#print $gptname."\n";
my $specfilename = "./fedora/" . $gptname . ".spec";
$specfilename =~ tr/_/-/;

if ($verbose){print "Acting on $specfilename \n";}

my $name = $gptname;
$name =~ tr/_/-/;

my $version = $gptmajorver . '.' . $gptminorver;

if (!open(FH, "+< $specfilename"))
{
    print "Error opening: $specfilename\n";
    next; 
}
my @ARRAY = <FH>; 
# change ARRAY here 
my $index;
my $changelogindex;
my $releaseindex;
my $releaseversion;
my $setreleaseversion;
my $releasesuffix;
my $specfile_changed = "";
my $version_changed = 0;

foreach my $specline (@ARRAY)
{
    if ($specline =~ m/Version:\s*(\d+\.\d+)/)
    {
        if ($1 ne $version)
        {
            $specline = "Version:\t$version\n";
            $setreleaseversion = 1;
            $version_changed = 1;
        }
    }
    elsif ($specline =~ m/Release:\s*(\d+)(.*)/)
    {
        $releaseindex = $index;
        $releaseversion = $1;
        $releasesuffix = $2;
    }
    elsif ($specline =~ m/\%changelog/)
    {
        $changelogindex = $index;
    }
    elsif ($specline =~ m/(Requires:\s*(\S*)\s*>=\s*)([0-9.]+)/)
    {
        # Kind of ugly here. What we do is see if the requirement package
        # name is a gpt dependency. We try some variations on the name
        # by stripping off common suffixes in the spec files. As long as
        # no gpt package names end with any of these suffixes, this should work
        my $requirement = $2;
        my $requirever = $3;
        my $old_requirever = $3;
        my $base_requirement;
        my @specsuffixes = ('', '-clients', '-devel', '-libs',
            '-progs', '-server', '-setup-poll', '-setup-seg');

        $base_requirement = $requirement;
        $base_requirement =~ s/\%{\?_isa}//;

        for my $suffix (@specsuffixes)
        {
            if ($base_requirement =~ m/$suffix$/)
            {
                my $new_base = $base_requirement;
                $new_base =~ s/$suffix$//;

                if (exists $depsuntyped{$new_base})
                {
                    $requirever = $depsuntyped{$new_base};
                    last;
                }
            }
        }
        if ($requirever != $old_requirever)
        {
            print "Updating version $requirement from $old_requirever to $requirever\n" if ($verbose);
            $specline =~ s/(Requires:\s*\S+\s*>=\s*)[0-9.]+/$1$requirever/;
            $specfile_changed = 1;
        }
    }
    elsif ($specline =~ m/^Source:\s*(\S*)/ && $gtrelease)
    {
        if ($1 !~ m/$gtrelease/)
        {
            my $filename = $1;
            $filename =~ s/.*\///;
            $specline =~ s/^(Source:\s*)(\S*)(.*)/$1$gtreleaseuri$filename/;
            $specfile_changed = 1;
        }
    }

    $index++;
}

my $changelogstring;

if ($cvs_changelog && $gtrelease)
{
    my ($major, $minor, $micro) = split(/\./, $gtrelease);
    my $old_tag = "globus_${major}_${minor}_" . ($micro-1);
    my $new_tag = "globus_${major}_${minor}_branch";

    my $changelogdir = $specfilename;
    $changelogdir = $gptmetadata;
    $changelogdir =~ s|(/pkgdata)?/pkg_data_src.gpt(.in)?||;
    chomp($changelog = `cvs -q log -N -r$old_tag::$new_tag $changelogdir 2> /dev/null | grep -E '^[A-Z]+-[0-9]+'  | sort -u`);

    if ($changelog eq '')
    {
        $changelog = undef;
    }
}

if (!$changelog)
{
    if ($prompt_for_changelog)
    {
        print "Changelog entry [empty line to end]: ";
        $changelogstring = '';

        while (<>)
        {
            if ($_ eq "\n")
            {
                last;
            }
            $changelogstring .= "- $_";
        }
    }

    if ($changelogstring eq '')
    {
        $changelogstring = "- Updated version numbers\n";
    }
}
else
{
    $changelogstring = "- " . join("\n- ", split(/\n/, $changelog)) . "\n";
}

if ($specfile_changed || $bumprelease)
{
    $releaseversion++;
}

if ($setreleaseversion)
{
    $releaseversion = $setreleaseversion;
}

if ($specfile_changed || $version_changed || $bumprelease)
{
    $ARRAY[$changelogindex] = "%changelog\n* " . strftime('%a %b %d %Y', localtime) . " $fullname <$email> - $version-$releaseversion\n$changelogstring\n";
    print "Spec file $specfilename has been updated\n";
}

  $ARRAY[$releaseindex] = "Release:\t$releaseversion$releasesuffix\n";

#Write back the spec file
seek(FH,0,0) or die "Seeking: $!"; 
print FH @ARRAY or die "Printing: $!"; 
truncate(FH,tell(FH)) or die "Truncating: $!"; 
close(FH) or die "Closing: $!";
}

__END__

=head1 NAME

B<rectify-spec-versions> - Rectify package versions from GPT metadata

=head1 SYNOPSIS

B<rectify-spec-versions> [options] 

Options:

=over

=item B<-gptfile> filename

The package's GPT source package description file (if you want to update only one package metadata)

=item B<-packagelist> filename

The list of packages/source locations to operate on.  Defaults to etc/package-list-5.1.0.  If gptfile is specified, it overrides any packagelist

=item B<-email> emailaddress

The packagers e-mail address (default: username@hostname)

=item B<-fullname> NAME

The packager's full name (default: determine from getpwent)

=item B<-verbose> 

Output info about each spec file being considered instead of just those changed.

=item B<-release> GT-RELEASE-VERSION

Update the source URL to the source directory for the GT-RELEASE-VERSION

=item B<-changelog> MESSAGE

Use MESSAGE as the changelog message, instead of the default [Updated version numbers]

=item B<-bumprelease>

Increase the package release number and update the changelog, even if has changed in the
GPT metadata.
