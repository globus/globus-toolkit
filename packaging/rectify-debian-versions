#! /usr/bin/perl

use Getopt::Long;
use POSIX;
use XML::Parser;
use User::pwent;
use Sys::Hostname;
use Pod::Usage;
use Data::Dumper;
use strict;

my $gptfile;
my $setupfile;
my $email = "support\@globus.org";
my $nodoc;
my $help;
my $packagelistfile;
my $verbose;
my $gtrelease = undef;
my $gtreleaseuri = undef;
my $changelog_from_cvs = 0;
my $changelog = undef;
my $fullname = "Globus Toolkit";
my $bumprelease = 0;

GetOptions('gptfile=s' => \$gptfile,
           'packagelistfile=s' => \$packagelistfile,
           'email=s' => \$email,
           'verbose' => \$verbose,
           'fullname=s' => \$fullname,
           'release=s' => \$gtrelease,
           'changelog=s' => \$changelog,
           'cvs-changelog' => \$changelog_from_cvs,
           'bumprelease' => \$bumprelease,
           'help' => \$help);

Pod::Usage::pod2usage() if defined $help;

setlocale(LC_TIME, 'C');

if (!$gtrelease)
{
    my $fh;
    open($fh, "<fait_accompli/version");
    chomp($gtrelease=<$fh>);
    close($fh);
}

$gtrelease =~ m/^([0-9])+\.([0-9]+)\.([0-9]+)$/;
$gtreleaseuri="http://www.globus.org/ftppub/gt$1/$1.$2/$gtrelease/packages/src/";

my $login = getlogin || getpwuid($<);
my $pw = getpwnam($login);
my $host = hostname;

$fullname = (split(/,/, $pw->gecos))[0] unless defined $fullname;
$email = "$login\@$host" unless defined $email;

my @packagelist;
if ($packagelistfile ne '')
{
    open(PKG, "$packagelistfile");
}
else
{
    open(PKG, "etc/package-list-5.1.0");
}
while ( <PKG> )
{
    my ($pkg, $subdir, $pnb, $pkgtag) = split(' ', $_);
    next if ($pkg =~ m/^#/ || $pkg =~ m/^$/);

    next if ($pkg =~ m/openssh/);
    push(@packagelist, "source-trees/".$subdir."\/pkgdata\/pkg_data_src.gpt.in");
}

my $allpkgmeta = {};
my $gptpkgname;

# Parse the metadata into an object that contains the name, version,
# and dependencies
$gptfile =~ s!^\./!!;
$gptfile =~ s!/\./|//!!g;
foreach my $gptmetadata (@packagelist)
{
    my $pkgmeta = parse_package($gptmetadata);

    if ($gptmetadata eq $gptfile)
    {
        $gptpkgname = $pkgmeta->{DEBNAME};
    }
    $allpkgmeta->{$pkgmeta->{DEBNAME}} = $pkgmeta;
}

# Fake one for GPT
$allpkgmeta->{'grid-packaging-tools'} = create_meta_for_gpt();

if ($gptfile)
{
    update_debian($gptpkgname, $allpkgmeta, $bumprelease);
}
else
{
    foreach my $pkgname (keys %$allpkgmeta)
    {
        update_debian($pkgname, $allpkgmeta, 0);
    }
}

sub parse_package
{
    my $parser = new XML::Parser(Style => 'Objects', Pkg => 'GPT');

    my %srcdeps;
    my %depsuntyped;
    my %setupdeps;

    my $gptdoc = $parser->parsefile($_[0]);

    my $gptmeta = $gptdoc->[0];
    my $gptname = $gptmeta->{Name};

    my $gptagingver =
        (grep {$_->isa('GPT::Aging_Version')} @{$gptmeta->{Kids}})[0];
    my $gptmajorver = $gptagingver->{Major};
    my $gptminorver = $gptagingver->{Minor};
    my $gptage      = $gptagingver->{Age};

    my $gptdesc =  (grep {$_->isa('GPT::Description')} @{$gptmeta->{Kids}})[0];
    my $description = $gptdesc->{Kids}->[0]->{Text};
    $description =~ s!^\s+|\s+$!!g;

    my $srcpkg = (grep {$_->isa('GPT::src_pkg')} @{$gptmeta->{Kids}})[0];
    for my $srcdep (
            grep {$_->isa('GPT::Source_Dependencies')} @{$srcpkg->{Kids}})
    {
        my $type = $srcdep->{Type};
        $srcdeps{$type} = {} unless defined $srcdeps{$type};
        for my $dep (grep {$_->isa('GPT::Dependency')} @{$srcdep->{Kids}})
        {
            my $depname = $dep->{Name};
            my $deppkg = $dep->{Package} if defined $dep->{Package};
            $depname = $depname . "-progs" if ($deppkg eq "pgm");
            $depname = $depname . "-doc" if ($deppkg eq "doc");
            $depname = "lib$depname" . $dep->{SONAME} if ($deppkg eq "rtl");
            $depname = "lib$depname" . "-dev" if ($deppkg eq "dev");
            $depname = "lib$depname" . "-dev" if ($type eq "compile");
            $depname =~ tr/_/-/;
            my $baz = (grep {$_->isa('GPT::Version')} @{$dep->{Kids}})[0];
            my $depver_element = (grep {$_->isa('GPT::Simple_Version')}
                @{$baz->{Kids}})[0];
            my $depver = $depver_element->{Major};
            $srcdeps{$type}{$depname} = $depver
                unless (defined $srcdeps{$type}{$depname}
                        and $srcdeps{$type}{$depname} >= $depver);
            $depsuntyped{$depname} = $depver
                unless (defined $depsuntyped{$depname}
                        and $depsuntyped{$depname} >= $depver);
        }
    }
    my $debname = $gptname;
    $debname =~ tr/_/-/;

    my $soname = int($gptmajorver) - int($gptage);

    return {
        GPTFILE => $_[0],
        NAME => $gptname,
        DEBNAME => $debname,
        MAJOR => $gptmajorver,
        MINOR => $gptminorver,
        AGE => $gptage,
        SONAME => $soname,
        SRCDEPS => \%srcdeps,
        DEPSUNTYPED => \%depsuntyped
    };
}

sub create_meta_for_gpt
{
    my $pkgmeta;
    my $gptver;
    my $fh;

    open($fh, "<gpt/gpt_version");
    chomp($gptver = <$fh>);
    close($fh);

    $gptver =~ m/^([0-9]+)\.([0-9]+)$/;

    $pkgmeta = {
        NAME => 'gpt',
        DEBNAME => 'grid-packaging-tools',
        MAJOR => $1,
        MINOR => $2,
        AGE => 0,
        SONAME => $1,
        SRCDEPS => {},
        DEPSUNTYPED => {}
    };

    return $pkgmeta;
}

sub update_debian
{
    my ($pkgname, $allpkgmeta, $changed) = @_;
    my $pkgmeta = $allpkgmeta->{$pkgname};

    if ($verbose) {print "Acting on files in ./debian/$pkgname/debian\n";}

    my $version = "$pkgmeta->{MAJOR}.$pkgmeta->{MINOR}";

    $changed |= update_rules($pkgmeta);
    $changed |= update_control($pkgmeta, $allpkgmeta);
    $changed |= check_if_version_is_different($pkgmeta);
    $changed |= check_if_debian_metadata_changed($pkgmeta);
    update_changelog($pkgmeta) if ($changed);
}

# Things to change in a control file:
# Package names:
#    There might be a package called lib$packagename$soname which might need
#    an soname update.
# Build Dependencies: 
#    This package might have a build dependency on a package whose version has
#    changed. The name might be mangled with the addition of a suffix:
#        -admin | -dbg | -dev | -doc | -progs | -server
#    or with prefix lib and suffix -dev
# Dependencies:
#    This package might have a runtime dependence on a package whose version has
#    changed. The name might be mangled with the addition of a suffix:
#        -admin | -dbg | -dev | -doc | -progs | -server
#    or with a prefix "lib" and suffix "-dev" or a prefix "lib" and suffix
#    "$soname"
# Description:
#    The description might contain references to lib PKGNAME SONAME in its
#    auto-generated description text
sub update_control
{
    my ($pkgmeta, $allpkgmeta) = @_;
    my $controlpath = "./debian/$pkgmeta->{DEBNAME}/debian/control";
    my $soname = $pkgmeta->{SONAME};
    my $changed = 0;
    my $fd;
    my @old_control;
    my $in_description = 0;

    open($fd, "<$controlpath") || return 0;
    @old_control=<$fd>;
    close($fd);

    for my $line (@old_control)
    {
        chomp($line);
        if (($in_description || $line =~ m/^Description/) && $line ne '')
        {
            $in_description = 1;
            $changed |= ($line =~ s/lib$pkgmeta->{DEBNAME}([0-9]+)/lib$pkgmeta->{DEBNAME}$pkgmeta->{SONAME}/g);

        }
        elsif ($in_description && $line eq '')
        {
            $in_description = '';
        }
        elsif ($line =~ /^(Package:\s*lib$pkgmeta->{DEBNAME})(\d+)$/)
        {
            my ($oldname, $oldsoname) = ($1, $2);
            print "Checking if Package name line needs update ($line)\n"
                if ($verbose);
	    print "Old soname is $oldsoname, new soname is $soname\n"
                if ($verbose);
            if ($oldsoname ne '' && $soname != int($oldsoname))
            {
                $line =~s/^(Package:\s*lib$pkgmeta->{DEBNAME})(\d+)$/$oldname$soname/;
                print "new line ($line)\n" if ($verbose);
                $changed = 1;
            }
        }
        elsif ($line =~ /^Build-Depends:/)
        {
            my @dependencies;

            @dependencies = split(/: |, /, $line);

            # Skip "Build-Depends: " token
            shift(@dependencies);

            for my $dep (@dependencies)
            {
                if ($dep =~ m/^(?!lib)(\S+?)(-admin|-dbg|-dev|-doc|-progs|-server)?\s*(\((.*)\))/)
                {
                    # Handle the suffix-only case
                    my ($basename, $suffix, $dependency_pred) = ($1, $2, $4);

                    # if there's a dependency on $basename and a (>= $version)
                    # associated with that dependency, update the $version
                    # part to match the GPT dependency for that package
                    if ($pkgmeta->{DEPSUNTYPED}->{$basename}
                        && $dependency_pred)
                    {
                        print "GPT dependency is for "
                            . $pkgmeta->{DEPSUNTYPED}->{$basename}
                            . "\n" if ($verbose);
                        if ($dependency_pred =~ m/>=\s*([0-9\.]+)/)
                        {
                            my $newdep;
                            $newdep = "$basename$suffix (>= "
                                . $pkgmeta->{DEPSUNTYPED}->{"$basename$suffix"}
                                . ")";

                            if ($newdep ne $dep)
                            {
                                $dep = $newdep;
                                $changed = 1;
                            }
                        }

                    }
                }
                elsif ($dep =~
                    m/^lib([a-z-]+)([0-9]+)?(-dev)(\s* \(>=\s*([0-9.]+)\))$/)
                {
                    # Handle the library case (maybe with soname and -dev
                    # suffix)
                    my ($libname, $soname, $dev, $depver) = ($1, $2, $3, $5);
                    my ($newsoname, $newdepver);
                    my ($newdep, $thischanged);
                    print "Checking if dependency on lib$libname$soname$dev "
                        . "$depver needs update\n" if ($verbose);
                    print "Depends on lib$libname$dev "
                        . $pkgmeta->{DEPSUNTYPED}->{"lib$libname$dev"}
                        . "\n" if ($verbose);

                    # If the dependency has either a soname appended to the
                    # library name or a (>= $version), compare them to 
                    # the GPT package dependency version and soname for the 
                    # package
                    $newdepver = $pkgmeta->{DEPSUNTYPED}->{"lib$libname$dev"};
                    $newsoname = $allpkgmeta->{$libname}->{SONAME};
                    if ($depver && $depver ne $newdepver)
                    {
                        $depver = $newdepver;
                        $thischanged = 1;
                    }
                    if ($soname && $soname ne $newsoname)
                    {
                        $soname = $newsoname;
                        $thischanged = 1;
                    }

                    if ($thischanged)
                    {
                        $dep = "lib$libname$soname$dev"
                            . ($depver ? " (>= $depver)" : "");
                        $changed = 1;
                    }
                }
            }
            # Combine the dependencies back into a single line
            $line = "Build-Depends: " . join(", ", @dependencies);
        }
        elsif ($line =~ m/^Depends:/)
        {
            # Depends:
            #    This package might have a runtime dependence on a package
            #    whose version has changed. The name might be mangled with the
            #    addition of a suffix:
            #        -admin | -dbg | -dev | -doc | -progs | -server
            #    or with addition of prefix + suffix
            #        lib PKGNAME -dev
            #    or with addition of prefix + suffix
            #        lib PKGNAME SONAME
            my @dependencies;

            @dependencies = split(/: |, /, $line);

            # Skip "Depends: " token
            shift(@dependencies);

            for my $dep (@dependencies)
            {
                if ($dep =~ m/^(?!lib)(\S+?)(-admin|-dbg|-dev|-doc|-progs|-server)?\s*(\((.*)\))/)
                {
                    my ($basename, $suffix, $dependency_pred) = ($1, $2, $4);

                    if ($pkgmeta->{DEPSUNTYPED}->{$basename} && $dependency_pred)
                    {
                        if ($dependency_pred =~ m/>=\s*([0-9\.]+)/)
                        {
                            my $newdep;
                            $newdep = "$basename$suffix (>= " . $pkgmeta->{DEPSUNTYPED}->{$basename}
                                . ")";

                            if ($newdep ne $dep)
                            {
                                $dep = $newdep;
                                $changed = 1;
                            }
                        }

                    }
                }
                elsif ($dep =~
                    m/^lib([a-z-]+)([0-9]+)?(-dev)?(\s* \(([<>=]+) ([^)]+)\))?$/)
                {
                    my ($basedep, $basedepsoname, $dev, $op, $depver) =
                        ($1, $2, $3, $5, $6);
                    my $newdep;
                    if ($basedep ne '')
                    {
                        if (exists $allpkgmeta->{$basedep}->{SONAME})
                        {
                            $basedepsoname = $allpkgmeta->{$basedep}->{SONAME};
                        }
                    }
                    if ($depver ne '' && $depver =~ m/[0-9.]+/)
                    {
                        $depver = $pkgmeta->{DEPSUNTYPED}->{$basedep};
                    }
                    $newdep = "lib$basedep" . ($basedepsoname ne ''?$basedepsoname:"")
                            . $dev . ($depver?" ($op $depver)" : "");
                    if ($newdep ne $dep)
                    {
                        $dep = $newdep;
                        $changed = 1;
                    }
                }
            }
            $line = "Depends: " . join(", ", @dependencies);
        }
    }
    if ($changed)
    {
        open($fd, ">$controlpath") || return 0;
        for my $line (@old_control)
        {
            print $fd "$line\n";
        }
        close($fd);
    }
    return $changed;
}

sub update_rules
{
    my ($pkgmeta) = @_;
    my ($package, $major, $minor, $age) =
        ($pkgmeta->{DEBNAME}, $pkgmeta->{MAJOR}, $pkgmeta->{MINOR}, $pkgmeta->{AGE});
    my $soname = $pkgmeta->{SONAME};
    my $rulespath = "debian/$package/debian/rules";
    my $fd;
    my @oldrules;
    my $changed = 0;

    open($fd, "<$rulespath") || return $changed;
    @oldrules = <$fd>;
    close($fd);

    open($fd, ">$rulespath.new") || return $changed;

    for my $line (@oldrules)
    {
        if ($line =~ m|^soname\s*=\s*(\d+)| && $1 ne $soname)
        {
            $line =~ s|^(soname\s*=\s*)(\d+)|$1$soname|;
            $changed = 1;
        }
        elsif ($line =~ m|^version\s*=\s*([0-9\.]+)| && $1 ne "$major.$minor")
        {
            $line =~ s|^(version\s*=\s*)([0-9\.]+)|$1$major.$minor|;
            $changed = 1;
        }
        elsif ($line =~ m|^toolkit_version\s*=\s*([0-9\.]+)| && $1 ne $gtrelease)
        {
            $line =~ s|^(toolkit_version\s*=\s*)([0-9\.]+)|$1$gtrelease|;
        }
        print $fd $line;
    }

    if ($changed)
    {
        rename "$rulespath.new", $rulespath;
    }
    else
    {
        unlink "$rulespath.new";
    }

    return $changed;
}
sub check_if_version_is_different
{
    my $pkgmeta = shift;
    my $package = $pkgmeta->{DEBNAME};
    my $version = "$pkgmeta->{MAJOR}.$pkgmeta->{MINOR}";
    my $old_version;
    my @oldchanges;
    my $fd;
    my $changelogpath = "debian/$package/debian/changelog";
    my $update;

    open($fd, "<$changelogpath") || return 0;
    @oldchanges = <$fd>;
    close($fd);

    if ($oldchanges[0] =~ /\S\s+\(([0-9.]*)-.*\)/)
    {
        $old_version = $1;
        if ($old_version ne $version)
        {
            return 1;
        }
    }
    return 0;
}

sub check_if_debian_metadata_changed
{
    my $pkgmeta = shift;
    my $package = $pkgmeta->{DEBNAME};
    my $debianpath = "debian/$package/debian";
    my $changelogpath = "debian/$package/debian/changelog";
    my $changelogmtime;

    $changelogmtime = int((stat($changelogpath))[9]);

    for my $filename (<$debianpath/*>)
    {
        if (-f $filename && int((stat($filename))[9]) > $changelogmtime)
        {
            print "$filename is newer than changelog\n" if $verbose;
            return 1;
        }
    }
    return 0;
}

sub update_changelog
{
    my $pkgmeta = $_[0];
    my $package = $pkgmeta->{DEBNAME};
    my $version = "$pkgmeta->{MAJOR}.$pkgmeta->{MINOR}";
    my @oldchanges;
    my $fd;
    my $changelogpath = "debian/$package/debian/changelog";
    my $update;
    my $release = 1;

    open($fd, "<$changelogpath") || return 0;
    @oldchanges = <$fd>;
    close($fd);

    if ($oldchanges[0] =~ /\(([0-9\.]+)-([^)]*)\)/)
    {
        my ($oldversion, $oldrelease) = ($1, $2);

        if ($oldversion eq $version)
        {
            $release = int($oldrelease) + 1;
        }
    }

    $update = "$package ($version-$release) unstable; urgency=low\n\n";

    if ($changelog_from_cvs)
    {
        my ($major, $minor, $micro) = split(/\./, $gtrelease);
        my $old_tag = "globus_${major}_${minor}_" . ($micro-1);
        my $new_tag = "globus_${major}_${minor}_branch";
        
        my $changelogdir = $pkgmeta->{GPTFILE};
        $changelogdir =~ s|(/pkgdata)?/pkg_data_src.gpt(.in)?||;
        chomp($changelog = `cvs -q log -N -r$old_tag::$new_tag $changelogdir 2> /dev/null | grep -E '^[A-Z]+-[0-9]+'  | sort -u`);

        if ($changelog eq '')
        {
            $changelog = "Update version for $gtrelease";
        }
    }
    for my $line (split(/\n/, $changelog))
    {
        $update .= "  * $line\n";
    }
    $update .= "\n -- $fullname <$email>  "
            . strftime("%a, %d %b %Y %H:%M:%S %z\n\n", localtime);

    open($fd, ">$changelogpath");
    print $fd $update;
    print $fd join('', @oldchanges);
    close($fd);
    return 1;
}

__END__

=head1 NAME

B<rectify-spec-versions> - Rectify package versions from GPT metadata

=head1 SYNOPSIS

B<rectify-spec-versions> [options] 

Options:

=over

=item B<-gptfile> filename

The package's GPT source package description file (if you want to update only
one package's metadata). Note that other GPT metadata will be parsed to
determine library verions for debian dependencies.

=item B<-packagelist> I<filename>

The list of packages/source locations to operate on.  Defaults to
etc/package-list-5.1.0.  If the -gptfile option is specified, then its 
argument will be the only package updated; otherwise, all packages in
I<filename> will be updated

=item B<-email> I<emailaddress>

The packager's e-mail address (default: username@hostname). This is included
in the debian changelog

=item B<-fullname> I<name>

The packager's full name (default: determined from getpw*). This is included
int he debian changelog.

=item B<-release> I<version>

Set the package source directory to one based on the Globus Toolkit version
I<version>. If not specified, the source URL path will not be updated.

=item B<-changelog> I<text>

Set the package's changelog entry to be I<text>.

=item B<-bumprelease>

Increase the package's release number even if the package version or
dependencies haven't changed.

=item B<-help>

Display this help text

=item B<-verbose> 

Output info about files being considered for modification and reasons why.

