#!/usr/bin/perl

#
# Do a perl check for version >= 5.005.  See 'gpt-translate-interpreter' should you
# need to alter the invocation path to a valid perl interpreter in the GPT front-end
# programs.
#

if ( ! ( defined eval "require 5.005" ) )
{
    die "GPT requires at least Perl version 5.005";
}

#
# dig the globus and gpt paths out of the user's environment variables
#

my $gpt_path = $ENV{GPT_LOCATION};
my $globus_path = $ENV{GLOBUS_LOCATION};
my $gpath;

if ( !defined($gpt_path) && !defined($globus_path) )
{
    die("GPT_LOCATION or GLOBUS_LOCATION needs to be set before running this script");
}

if ( defined($gpt_path) )
{
    $gpath = $gpt_path;
}

if ( defined($globus_path) && !defined($gpath) )
{
    $gpath = $globus_path;
}

if ( ! -d "$globus_path/etc/globus_packages" )
{
    die("Can't find a globus_packages directory to work on in your GLOBUS_LOCATION!\n");
}

#
# standard includes
#

use strict;
use Config;
use Getopt::Long;
use Data::Dumper;

@INC = ("$gpath/lib/perl", "$gpath/lib/perl/$Config{'archname'}", @INC);

my( $all, $save, $verbose, $help, $version );

GetOptions( 'all' => \$all,
            'save' => \$save,
            'verbose!' => \$verbose,
            'help' => \$help,
            'version' => \$version,
          ) or Pod::Usage::pod2usage(1);

$all = 1;

Pod::Usage::pod2usage(0) if $help;
require Grid::GPT::GPTIdentity;
Grid::GPT::GPTIdentity::print_gpt_version() if defined $version;

if (!$all and (scalar(@ARGV) < 1) )
{
    die("ERROR: You must specify -all or a set of packages to convert!\n");
}

require Grid::GPT::PackageFilelist;
require Grid::GPT::PkgFileName;
require Grid::GPT::Installation;

#
# begin main execution
#

my $installation = new Grid::GPT::Installation(
                              pkgdir => "$globus_path/etc/globus_packages",
                              with_filelists => 0,
                              );

my $pkgs = [];

if (defined($all) and $all)
{
    $pkgs = $installation->query();
}
else
{
    for my $l (@ARGV)
    {
        my $parsed = Grid::GPT::PkgFileName::parse_name($l);
        my $querypkgs = $installation->query(
                pkgname => $parsed->{'pkgname'},
                flavor => $parsed->{'flavor'},
                pkgtype => $parsed->{'pkgtype'},
                );
        push(@$pkgs, @$querypkgs);
    }
}

my @list;

for my $pkg (@$pkgs)
{
    my $fl = new Grid::GPT::PackageFilelist(
                        context => "installdir",
                        contextData => { dir => $ENV{'GLOBUS_LOCATION'}, },
                        pkgnode => $pkg,
                        convert => 0,
                        );

    if (!defined($fl))
    {
        die("ERROR: package filelist object is undefined.\n");
    }

    $fl->open();

    push(@list, $fl);
}

#
# filelists init'd
#

printf("filelists created\n");

my $foo = @list[0]->getFilelistFiles();
printf("%s", Dumper($foo));

printf("copying filelists\n");
@list[0]->copyFilelist(@list[1]);

my $foo = @list[0]->getFilelistFiles();
printf("%s", Dumper($foo));

if ($save)
{
    @list[0]->save();
}
