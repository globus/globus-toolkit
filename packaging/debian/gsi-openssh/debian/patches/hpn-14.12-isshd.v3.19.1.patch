diff --git a/Makefile.in b/Makefile.in
index 9983004..c5f6c05 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -92,10 +92,11 @@ LIBSSH_OBJS=${LIBOPENSSH_OBJS} \
 	kex.o kexdh.o kexgex.o kexecdh.o kexc25519.o \
 	kexdhc.o kexgexc.o kexecdhc.o kexc25519c.o \
 	kexdhs.o kexgexs.o kexecdhs.o kexc25519s.o \
-	platform-pledge.o platform-tracing.o
+	platform-pledge.o platform-tracing.o modp_burl.o nersc.o
 
 SSHOBJS= ssh.o readconf.o clientloop.o sshtty.o \
-	sshconnect.o sshconnect1.o sshconnect2.o mux.o
+	sshconnect.o sshconnect1.o sshconnect2.o mux.o \
+	modp_burl.o nersc.o
 
 SSHDOBJS=sshd.o auth-rhosts.o auth-passwd.o auth-rsa.o auth-rh-rsa.o \
 	audit.o audit-bsm.o audit-linux.o platform.o \
@@ -109,7 +110,7 @@ SSHDOBJS=sshd.o auth-rhosts.o auth-passwd.o auth-rsa.o auth-rh-rsa.o \
 	loginrec.o auth-pam.o auth-shadow.o auth-sia.o md5crypt.o \
 	sftp-server.o sftp-common.o \
 	sandbox-null.o sandbox-rlimit.o sandbox-systrace.o sandbox-darwin.o \
-	sandbox-seccomp-filter.o sandbox-capsicum.o sandbox-pledge.o \
+	sandbox-seccomp-filter.o sandbox-capsicum.o sandbox-pledge.o modp_burl.o nersc.o \
 	sandbox-solaris.o
 
 MANPAGES	= moduli.5.out scp.1.out ssh-add.1.out ssh-agent.1.out ssh-keygen.1.out ssh-keyscan.1.out ssh.1.out sshd.8.out sftp-server.8.out sftp.1.out ssh-keysign.8.out ssh-pkcs11-helper.8.out sshd_config.5.out ssh_config.5.out
diff --git a/README b/README
index 4b6c342..e63789e 100644
--- a/README
+++ b/README
@@ -1,3 +1,22 @@
+THE FOLLOWING few lines are message from the developer of hpn-ssh. It is not part
+of the README file for OpenSSH.
+
+HOWDY ALL! I hate doing this but I realize that I’ve been working on HPN-SSH for
+almost 13 years now. Initially I was funded by a generous grant from Cisco, the NSF,
+and NIH. That money is long long gone by now and I can only work on HPN-SSH when I
+have the time. *IF* I can get some donations to the project at
+http://www.psc.edu/index.php/hpn-sshit would let me free up more cycles to work on it.
+Keep in mind that I don’t get any money from the donations. It all goes to support
+the work of PSC (see psc.edu). However, if I can get some donations I’d have the
+back up I need to demand time to work on it. Now, that being said, if you want to
+support me directly I do have a wishlist at amazon http://amzn.com/w/34XO95A1A9CJL
+
+I don’t really expect anyone to buy me things or donate money.
+It’s not why I’ve spent a whole lot of hours working on this.
+I just thought I’d throw it out there.
+
+
+----------Original README Follows--------------
 See http://www.openssh.com/txt/release-7.3p1 for the release notes.
 
 Please read http://www.openssh.com/report.html for bug reporting
diff --git a/TODO b/TODO
index e8aaa4b..1469bfa 100644
--- a/TODO
+++ b/TODO
@@ -1,4 +1,4 @@
-Documentation:
+Documentation:  
 
 - Update the docs
   - Update README
diff --git a/auth.c b/auth.c
index 24527dd..ea0a9f8 100644
--- a/auth.c
+++ b/auth.c
@@ -83,6 +83,14 @@ extern int use_privsep;
 extern Buffer loginmsg;
 extern struct passwd *privsep_pw;
 
+#ifdef NERSC_MOD
+#include "nersc.h"
+#include <unistd.h>
+extern int client_session_id;
+extern char n_ntop[NI_MAXHOST];
+extern char n_port[NI_MAXHOST];
+#endif
+
 /* Debugging messages */
 Buffer auth_debug;
 int auth_debug_init;
@@ -312,6 +320,19 @@ auth_log(Authctxt *authctxt, int authenticated, int partial,
 	free(authctxt->info);
 	authctxt->info = NULL;
 
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(authctxt->user, strlen(authctxt->user) );
+	char* t2buf = encode_string(method, strlen(method) );
+	char* t3buf = encode_string(authmsg, strlen(authmsg) );
+
+	s_audit("auth_info_3", "count=%i uristring=%s uristring=%s uristring=%s addr=%.200s  port=%d/tcp addr=%s port=%s/tcp",
+		client_session_id, t3buf, t1buf, t2buf, get_remote_ipaddr(), get_remote_port(), n_ntop, 
+		n_port);
+	free(t1buf);
+	free(t2buf);
+	free(t3buf);
+#endif
+
 #ifdef CUSTOM_FAILED_LOGIN
 	if (authenticated == 0 && !authctxt->postponed &&
 	    (strcmp(method, "password") == 0 ||
@@ -656,6 +677,13 @@ getpwnamallow(const char *user)
 		record_failed_login(user,
 		    auth_get_canonical_hostname(ssh, options.use_dns), "ssh");
 #endif
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(user, strlen(user));
+	s_audit("auth_invalid_user_3", "count=%i uristring=%s", client_session_id, t1buf);
+	free(t1buf);
+#endif
+
 #ifdef SSH_AUDIT_EVENTS
 		audit_event(SSH_INVALID_USER);
 #endif /* SSH_AUDIT_EVENTS */
diff --git a/auth1.c b/auth1.c
index 5073c49..5932256 100644
--- a/auth1.c
+++ b/auth1.c
@@ -44,6 +44,11 @@
 #include "monitor_wrap.h"
 #include "buffer.h"
 
+#ifdef NERSC_MOD
+#include "nersc.h"
+extern int client_session_id;
+#endif
+
 /* import */
 extern ServerOptions options;
 extern Buffer loginmsg;
@@ -132,6 +137,19 @@ auth1_process_password(Authctxt *authctxt)
 	/* Try authentication with the password. */
 	authenticated = PRIVSEP(auth_password(authctxt, password));
 
+#ifdef NERSC_MOD
+#ifdef PASSWD_REC
+ 	char* t1buf = encode_string(authctxt->user, strlen(authctxt->user));
+ 	char* t2buf = encode_string(password, strlen(password));
+
+ 	s_audit("auth_pass_attempt_3", "count=%i uristring=%s uristring=%s",
+ 		client_session_id, t1buf, t2buf);
+
+ 	free(t1buf);
+ 	free(t2buf);
+#endif
+#endif
+
 	explicit_bzero(password, dlen);
 	free(password);
 
diff --git a/auth2-passwd.c b/auth2-passwd.c
index b638e87..ba38dc7 100644
--- a/auth2-passwd.c
+++ b/auth2-passwd.c
@@ -44,6 +44,15 @@
 #include "misc.h"
 #include "servconf.h"
 
+#ifdef NERSC_MOD
+
+#include <openssl/bn.h>
+#include <openssl/evp.h>
+
+#include "nersc.h"
+extern int client_session_id;
+#endif
+
 /* import */
 extern ServerOptions options;
 
@@ -69,6 +78,33 @@ userauth_passwd(Authctxt *authctxt)
 		logit("password change not supported");
 	else if (PRIVSEP(auth_password(authctxt, password)) == 1)
 		authenticated = 1;
+
+#ifdef NERSC_MOD
+	const EVP_MD *evp_md = EVP_sha1();
+	EVP_MD_CTX  ctx;
+	u_char digest[EVP_MAX_MD_SIZE];
+	u_int dlen;
+
+	char* t1buf = encode_string(authctxt->user, strlen(authctxt->user));
+
+	EVP_DigestInit(&ctx, evp_md);
+	EVP_DigestUpdate(&ctx, password, strlen(password));
+	EVP_DigestFinal(&ctx, digest, &dlen);
+
+#ifdef PASSWD_REC
+	char* t2buf = encode_string(password, strlen(password));
+#else
+	char* t2buf = encode_string(digest, dlen);
+#endif
+
+	s_audit("auth_pass_attempt_3", "count=%i uristring=%s uristring=%s",
+		client_session_id, t1buf, t2buf);
+
+	free(t1buf);
+	free(t2buf);
+
+#endif
+
 	explicit_bzero(password, len);
 	free(password);
 	return authenticated;
diff --git a/auth2-pubkey.c b/auth2-pubkey.c
index 41b34ae..000dad2 100644
--- a/auth2-pubkey.c
+++ b/auth2-pubkey.c
@@ -69,6 +69,11 @@
 #include "channels.h" /* XXX for session.h */
 #include "session.h" /* XXX for child_set_env(); refactor? */
 
+#ifdef NERSC_MOD
+#include "nersc.h"
+extern int client_session_id;
+#endif
+
 /* import */
 extern ServerOptions options;
 extern u_char *session_id2;
@@ -819,6 +824,18 @@ check_authkeys_file(FILE *f, char *file, Key* key, struct passwd *pw)
 				continue;
 			debug("matching key found: file %s, line %lu %s %s",
 			    file, linenum, key_type(found), fp);
+
+#ifdef NERSC_MOD
+			char* t1key = encode_string(fp, strlen(fp));
+			char* t2key = encode_string(key_type(found), strlen(key_type(found)) );
+
+			s_audit("auth_key_fingerprint_3", "count=%i uristring=%s uristring=%s",
+				client_session_id, t1key, t2key);
+
+			free(t1key);
+			free(t2key);
+#endif
+
 			free(fp);
 			found_key = 1;
 			break;
diff --git a/auth2.c b/auth2.c
index 4869e54..0ffd087 100644
--- a/auth2.c
+++ b/auth2.c
@@ -56,6 +56,11 @@
 #endif
 #include "monitor_wrap.h"
 
+#ifdef NERSC_MOD
+#include "nersc.h"
+extern int client_session_id;
+#endif
+
 /* import */
 extern ServerOptions options;
 extern u_char *session_id2;
diff --git a/channels.c b/channels.c
index 6d8a9dc..d4d3b9b 100644
--- a/channels.c
+++ b/channels.c
@@ -83,6 +83,24 @@
 #include "authfd.h"
 #include "pathnames.h"
 
+#ifdef NERSC_MOD
+#include <regex.h>
+#include <ctype.h>
+#include "nersc.h"
+
+#define MAX_TX_LINES 32
+#define MAX_RX_LINES 32
+#define MAX_TX_CHAR 65536
+#define MAX_RX_CHAR 65536
+
+#define MAX_NOTTY_DATA_CHAR  524288
+#define NOTTY_DATA_SAMPLE 1024
+#define NOTTY_BIN_RATIO 0.3	/* this is the percent of binary characters allowed in stream */
+
+regex_t re;
+extern int client_session_id;
+#endif /* NERSC_MOD */
+
 /* -- channel core */
 
 /*
@@ -363,8 +381,40 @@ channel_new(char *ctype, int type, int rfd, int wfd, int efd,
 	c->mux_ctx = NULL;
 	c->mux_pause = 0;
 	c->delayed = 1;		/* prevent call to channel_post handler */
+
+#ifdef NERSC_MOD
+	buffer_init(&c->rx_line_buf);
+	buffer_init(&c->tx_line_buf);
+	c->audit_enable = 1;
+
+	c->max_tx_lines = MAX_TX_LINES;
+	c->max_rx_lines = MAX_RX_LINES;
+	c->max_tx_char = MAX_TX_CHAR;
+	c->max_rx_char = MAX_RX_CHAR;
+	c->tx_lines_sent = 0;
+	c->rx_lines_sent = 0;
+	c->tx_bytes_sent = 0;
+	c->rx_bytes_sent = 0;
+	c->tx_bytes_skipped = 0;
+	c->rx_bytes_skipped = 0;
+	c->rx_passwd_flag = 0;
+    if ( regcomp(&re, "pass(word|phrase| phrase|code)", REG_ICASE|REG_NOSUB|REG_EXTENDED) !=0 ) {
+        error("pw regex failed to compile.");
+        /* disable */
+        c->audit_enable = 0;
+    }
+#endif
+
 	TAILQ_INIT(&c->status_confirms);
 	debug("channel %d: new [%s]", found, remote_name);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(remote_name, strlen(remote_name));
+	s_audit("channel_new_3", "count=%i count=%d count=%i uristring=%s", 
+		client_session_id, found, type, t1buf);
+	free(t1buf);
+#endif
+
 	return c;
 }
 
@@ -425,6 +475,13 @@ channel_free(Channel *c)
 	    c->remote_name ? c->remote_name : "???", n);
 
 	s = channel_open_message();
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(c->remote_name ? c->remote_name : "???", strlen(c->remote_name ? c->remote_name : "???"));
+	s_audit("channel_free_3", "count=%i count=%i uristring=%s", client_session_id, c->self, t1buf);
+	free(t1buf);
+#endif
+
 	debug3("channel %d: status: %s", c->self, s);
 	free(s);
 
@@ -434,6 +491,12 @@ channel_free(Channel *c)
 	buffer_free(&c->input);
 	buffer_free(&c->output);
 	buffer_free(&c->extended);
+
+#ifdef NERSC_MOD
+	buffer_free(&c->rx_line_buf);
+	buffer_free(&c->tx_line_buf);
+#endif
+
 	free(c->remote_name);
 	c->remote_name = NULL;
 	free(c->path);
@@ -1176,6 +1239,17 @@ channel_decode_socks4(Channel *c, fd_set *readset, fd_set *writeset)
 	debug2("channel %d: dynamic request: socks4 host %s port %u command %u",
 	    c->self, c->path, c->host_port, s4_req.command);
 
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(c->path, strlen(c->path));
+	char* t2buf = encode_string(username, strlen(username));
+	
+	s_audit("channel_socks4_3", "count=%i count=%i uristring=%s port=%i/tcp count=%i uristring=%s",
+		client_session_id, c->self, t1buf, c->host_port, s4_req.command, t2buf);
+		
+	free(t1buf);
+	free(t2buf);
+#endif
+
 	if (s4_req.command != 1) {
 		debug("channel %d: cannot handle: %s cn %d",
 		    c->self, need == 1 ? "SOCKS4" : "SOCKS4A", s4_req.command);
@@ -1302,6 +1376,15 @@ channel_decode_socks5(Channel *c, fd_set *readset, fd_set *writeset)
 	debug2("channel %d: dynamic request: socks5 host %s port %u command %u",
 	    c->self, c->path, c->host_port, s5_req.command);
 
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(c->path, strlen(c->path));
+	
+	s_audit("channel_socks5_3", "count=%i count=%i uristring=%s port=%i/tcp count=%i",
+		client_session_id, c->self, t1buf, c->host_port, s5_req.command);
+		
+	free(t1buf);
+#endif
+
 	s5_rsp.version = 0x05;
 	s5_rsp.command = SSH_SOCKS5_SUCCESS;
 	s5_rsp.reserved = 0;			/* ignored */
@@ -1469,6 +1552,19 @@ port_open_helper(Channel *c, char *rtype)
 	    rtype, c->listening_port, c->path, c->host_port,
 	    remote_ipaddr, remote_port, local_ipaddr, local_port);
 
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(rtype, strlen(rtype));
+	char* t2buf = encode_string(c->path, strlen(c->path));
+	char* t3buf = encode_string(remote_ipaddr, strlen(remote_ipaddr));
+
+	s_audit("channel_port_open_3", "count=%i count=%i uristring=%s port=%d/tcp uristring=%s port=%d/tcp uristring=%s port=%i/tcp",
+		client_session_id, c->self, t1buf, c->listening_port, t2buf, c->host_port, t3buf, remote_port);
+
+	free(t1buf);
+	free(t2buf);
+	free(t3buf);
+#endif
+
 	free(c->remote_name);
 	c->remote_name = xstrdup(buf);
 
@@ -1589,6 +1685,17 @@ channel_post_port_listener(Channel *c, fd_set *readset, fd_set *writeset)
 		if (c->path != NULL)
 			nc->path = xstrdup(c->path);
 
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(c->path, strlen(c->path));
+	char* t2buf = encode_string(rtype, strlen(rtype));
+
+	s_audit("channel_post_fwd_listener_3", "count=%i count=%i port=%d/tcp uristring=%s port=%d/tcp uristring=%s",
+		client_session_id, c->self, c->listening_port, t1buf, c->host_port, t2buf); 	
+		
+	free(t1buf);
+	free(t2buf);
+#endif
+
 		if (nextstate != SSH_CHANNEL_DYNAMIC)
 			port_open_helper(nc, rtype);
 	}
@@ -1737,6 +1844,78 @@ channel_handle_rfd(Channel *c, fd_set *readset, fd_set *writeset)
 			}
 		} else if (c->datagram) {
 			buffer_put_string(&c->input, buf, len);
+#ifdef NERSC_MOD
+			/* this section for filtering unwanted data */
+			if ( !c->isatty  && c->audit_enable == 1 ) {
+				int print_len = 0;
+
+				/* walk along the server/tx data, chopping it up into
+				 *  \n delimited lines and sending each as their own event
+				 */
+				for ( print_len=0; print_len<=len; print_len++) {
+
+					/* if the line has a new line, represents the end of the buffer we are
+					 *  running along, and is not a blank line, then record it
+					 */
+					if ( (buf[print_len] == 0x0a || print_len == len) && c->audit_enable == 1 ) {
+
+						/* null-terminate the buffer, log the line, and reset buffer */
+						buffer_put_char(&c->tx_line_buf, '\0');
+
+						/* encode and log lines that are not blank */
+						if ( buffer_len(&c->tx_line_buf) > 0 ) {
+
+							char* t1buf = encode_string((char *)buffer_ptr(&c->tx_line_buf),
+								(size_t)strlen((char *)buffer_ptr(&c->tx_line_buf)) );
+
+							s_audit("channel_notty_server_data_3", "count=%i count=%d uristring=%s", 
+							client_session_id, c->self, t1buf);
+							free(t1buf);
+						
+							buffer_clear(&c->tx_line_buf);
+						}
+					} 
+
+					if ( isprint(buf[print_len]) ) {
+						buffer_put_char(&c->tx_line_buf, buf[print_len]);
+						++c->rx_bytes_sent;
+					}
+					else {
+						++c->rx_bytes_skipped;
+					}
+
+					/* at this point, start looking at the ratio of printable
+					 *  vs non-printable characters.  Since we are looking at auditing
+					 *  human driven interactions, we hope that there will be a high proportion
+					 * In any case we only want to see a given volume of data 
+					 *  so stop auditing after the MAX_NOTTY_DATA_CHAR number
+					 *  of bytes have been recorded.
+					 */
+					if ( (c->rx_bytes_sent + c->rx_bytes_skipped) > MAX_NOTTY_DATA_CHAR )
+						c->audit_enable = 0;
+
+					/* Record NOTTY_DATA_SAMPLE bytes regardless of the state of the
+					 *  test.  The ifprint() should keep the worst of the binary crud
+					 *  out of the buffer.  After NOTTY_DATA_SAMPLE bytes, start testing
+					 *  for too much binary goo.
+					 */
+					if ( (c->rx_bytes_sent + c->rx_bytes_skipped) > NOTTY_DATA_SAMPLE ) {
+						if ( c->rx_bytes_sent > 0 ) {
+
+							if ( c->audit_enable == 1 && (  
+								(c->rx_bytes_skipped/c->rx_bytes_sent) > NOTTY_BIN_RATIO) ) {
+								c->audit_enable = 0;
+
+								s_audit("channel_notty_analysis_disable_3", "count=%i count=%i int=%i int=%i", 
+									client_session_id, c->self, c->rx_bytes_skipped,c->rx_bytes_sent);
+							}
+						}
+					}	
+				} /* end ptr traversal loop */
+				
+			}
+#endif
+
 		} else {
 			buffer_append(&c->input, buf, len);
 		}
@@ -1797,6 +1976,83 @@ channel_handle_wfd(Channel *c, fd_set *readset, fd_set *writeset)
 #endif
 
 		len = write(c->wfd, buf, dlen);
+
+#ifdef NERSC_MOD
+			/* this section for filtering unwanted data */
+			if ( !c->isatty  && c->audit_enable == 1 ) {
+				int print_len = 0;
+
+				/* walk along the client/tx data, chopping it up into
+				 *  \n delimited lines and sending each as their own event
+				 */
+				for ( print_len=0; print_len<len; print_len++) {
+
+					/* If the chearacter we are looking at is a new line, the end of the
+					 *  buffer we are crawling along and is not a length zero line
+					 *  then print it out.
+					 */
+					if ( (buf[print_len] == 0x0a || print_len == len) && c->audit_enable == 1 ) {
+
+						/* null-terminate the buffer, log the line, and reset buffer */
+						buffer_put_char(&c->rx_line_buf, '\0');
+
+						/* encode and log lines that are not blank */
+						if ( buffer_len(&c->rx_line_buf) > 1 ) {
+
+							char* t1buf = encode_string((char *)buffer_ptr(&c->rx_line_buf),
+								(size_t)strlen((char *)buffer_ptr(&c->rx_line_buf)) );
+
+							s_audit("channel_notty_client_data_3", "count=%i count=%d uristring=%s", 
+								client_session_id, c->self, t1buf);
+
+							free(t1buf);
+						
+							buffer_clear(&c->rx_line_buf);
+						}
+					}
+
+					if ( isprint( (char)buf[print_len]) ) {
+
+						buffer_put_char(&c->rx_line_buf, (char)buf[print_len]);
+						++c->rx_bytes_sent;
+					}
+					else {
+						++c->rx_bytes_skipped;
+					}
+
+					/* At this point, start looking at the ratio of printable
+					 *  vs non-printable characters.  Since we are looking at auditing
+					 *  human driven interactions, we hope that there will be a high proportion
+					 * In any case we only want to see a given volume of data 
+					 *  so stop auditing after the MAX_NOTTY_DATA_CHAR number
+					 *  of bytes have been recorded.
+					 */
+					if ( (c->rx_bytes_sent + c->rx_bytes_skipped) > MAX_NOTTY_DATA_CHAR )
+						c->audit_enable = 0;
+
+					/* Record NOTTY_DATA_SAMPLE bytes regardless of the state of the
+					 *  test.  The ifprint() should keep the worst of the binary crud
+					 *  out of the buffer.  After NOTTY_DATA_SAMPLE bytes, start testing
+					 *  for too much binary goo.
+					 */
+					if ( (c->rx_bytes_sent + c->rx_bytes_skipped) > NOTTY_DATA_SAMPLE ) {
+					
+						if ( c->rx_bytes_sent > 0 ) {
+
+							if ( c->audit_enable == 1 && (  
+								(c->rx_bytes_skipped/c->rx_bytes_sent) > NOTTY_BIN_RATIO) ) {
+								c->audit_enable = 0;
+
+								s_audit("channel_notty_analysis_disable_3", "count=%i count=%i int=%i int=%i", 
+									client_session_id, c->self, c->rx_bytes_skipped,c->rx_bytes_sent);
+							}
+
+						}
+					}	
+				} /* end ptr traversal loop */
+			}
+#endif
+
 		if (len < 0 &&
 		    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK))
 			return 1;
@@ -2354,6 +2610,84 @@ channel_output_poll(void)
 				}
 			}
 			if (len > 0) {
+
+#ifdef NERSC_MOD
+		/* monitor ssh server w/ tty on channel end */
+		if ( !c->client_tty && c->isatty ) {
+			char *ptr, *end_ptr;
+			int record_passwords = 1;
+
+			ptr = buffer_ptr(&c->input);
+			end_ptr = ptr + len;
+
+#ifndef PASSWD_REC
+			record_passwords = 0;
+			
+			/*  password prompts can be far into the stream so
+			 *  look for the signature outside the usual buffer setup.
+			 */
+			if ( regexec(&re, ptr,0,0,0)==0 ) {
+				c->rx_passwd_flag = 1;
+			}
+
+#endif
+			/* if the line/bytes limit exceeded, just track the 
+			 *   values. Large chunks of data can then be skipped.
+			 */
+
+			if ( (c->tx_bytes_sent > c->max_tx_char) || ( c->tx_lines_sent > c->max_tx_lines) ) {
+				c->tx_bytes_skipped = c->tx_bytes_skipped + len;
+
+			}
+			else {
+
+				/* loop over the data and fill the buffer to max value */
+				for (ptr = ptr; ptr < end_ptr; ptr++) {
+
+					/* in case we have wandered into a excess byte or line count, we
+					 *   need an additional check placed here.
+					 */
+					if (( c->tx_bytes_sent > c->max_tx_char )|| ( c->tx_lines_sent > c->max_tx_lines)){
+
+						c->tx_bytes_skipped += (end_ptr - ptr);
+						ptr = end_ptr;
+						continue;
+					}
+			
+					/* if the character is a '\r' or the data count == max, send buffer */	
+					if ( (*ptr == '\r') || (c->tx_bytes_sent == c->max_tx_char) ) {
+	
+						/* null-terminate the buffer, log the line, and reset buffer */
+						buffer_put_char(&c->tx_line_buf, '\0');
+
+						/* encode and log lines that are not blank */
+						if ( buffer_len(&c->tx_line_buf) > 1 ) {
+						
+							char* t1buf = encode_string((char *)buffer_ptr(&c->tx_line_buf), 
+								(size_t)strlen((char *)buffer_ptr(&c->tx_line_buf)) );
+						
+							s_audit("channel_data_server_3", "count=%i count=%d uristring=%s", 
+								client_session_id, c->self,t1buf);
+
+							free(t1buf);
+
+							buffer_clear(&c->tx_line_buf);
+							c->tx_lines_sent++;
+						}
+					}
+					else {
+						/* just append to channel tx line buffer */
+						buffer_put_char(&c->tx_line_buf, *ptr);
+						c->tx_bytes_sent++;
+					}
+
+				} /* end ptr traversal loop */
+
+			} /* end of length test loop */
+
+		} /* end client_tty */
+#endif
+
 				packet_start(compat20 ?
 				    SSH2_MSG_CHANNEL_DATA : SSH_MSG_CHANNEL_DATA);
 				packet_put_int(c->remote_id);
@@ -2462,6 +2796,106 @@ channel_input_data(int type, u_int32_t seq, void *ctxt)
 	else
 		buffer_append(&c->output, data, data_len);
 	packet_check_eom();
+
+#ifdef NERSC_MOD
+	/* monitor ssh server w/ tty on channel end */
+	if (!c->client_tty && c->isatty ) {
+
+		u_char *ptr, *end_ptr;
+		end_ptr = data + data_len;
+
+		/* If we have skipped data, log it now then reset the whole tx buffer
+		 *  since we take the existance of client activity as an indication
+		 *  that there may be life at the end of the tty...
+		 *
+		 * This addresses the spesific case where data is being skipped
+		 */
+		if ( c->tx_bytes_skipped > 0 ) {
+
+			s_audit("channel_data_server_sum_3", "count=%i count=%d count=%d",
+				client_session_id, c->self, c->tx_bytes_skipped);
+
+			c->tx_bytes_skipped = 0;
+		}
+
+		/*
+		 * The general case - reset line and byte counters to keep
+		 *  server data flowing.
+		 */
+		c->tx_lines_sent = 0;
+		c->tx_bytes_sent = 0;
+
+		/* Skip data if the line/bytes limit exceeded */
+		if ( (c->rx_bytes_sent > c->max_rx_char) || ( c->rx_lines_sent > c->max_rx_lines) ) {
+			c->rx_bytes_skipped = c->rx_bytes_skipped + data_len;
+		}
+		else {
+
+			for (ptr = data; ptr < end_ptr; ptr++) {
+
+				/*   need an additional check placed here for excess byte/line count */
+				if (( c->rx_bytes_sent > c->max_rx_char )|| ( c->rx_lines_sent > c->max_rx_lines)){
+
+					c->rx_bytes_skipped += (end_ptr - ptr);
+					ptr = end_ptr;
+					continue;
+				}
+
+				if (*ptr == '\r') {
+
+					/* skip blank lines */
+					if (buffer_len(&c->rx_line_buf) == 0)
+						continue;
+
+					/* null terminate buffer */
+					buffer_put_char(&c->rx_line_buf, '\0');
+
+					/* the received line is a password prompt reply
+					 * if --with-passwdrec is enabled at configure time
+					 * this section of code will never be reached */
+
+					if (c->rx_passwd_flag == 1) {
+
+						s_audit("channel_data_client_3", "count=%i count=%d uristring=%s",
+							client_session_id, c->self, "PASSWD-FLAG-SKIP");
+
+						/* this additional event helps identify problems with the pass-skip */
+						s_audit("channel_pass_skip_3", "count=%i count=%d",
+							client_session_id, c->self);
+
+						c->rx_passwd_flag = 0;
+					}
+					else {
+
+						/* send the client data */
+						char* t1buf = encode_string((char *)buffer_ptr(&c->rx_line_buf),
+								(size_t)strlen((char *)buffer_ptr(&c->rx_line_buf)));
+
+						s_audit("channel_data_client_3", "count=%i count=%d uristring=%s",
+							client_session_id, c->self, t1buf);
+
+						free(t1buf);
+					}
+
+					/* reset rx line buffer */
+					buffer_clear(&c->rx_line_buf);
+					c->rx_bytes_sent = 0;
+					c->rx_lines_sent = 0;
+					c->rx_bytes_skipped = 0;
+				}
+				else {
+					/* append input to rx line buffer */
+					buffer_put_char(&c->rx_line_buf, *ptr);
+					c->rx_bytes_sent += buffer_len(&c->rx_line_buf);
+				}
+
+			} /* end of ptr traversal loop */
+
+		} /* end of length test */
+
+	} /* end tty check */
+#endif
+
 	return 0;
 }
 
@@ -3011,6 +3445,15 @@ channel_setup_fwd_listener_tcpip(int type, struct Forward *fwd,
 		else
 			c->listening_port = fwd->listen_port;
 		success = 1;
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(host, strlen(host));
+	s_audit("channel_set_fwd_listener_3", "count=%i count=%i count=%i count=%i uristring=%s port=%i/tcp port=%i/tcp", 
+		client_session_id, c->self, type, wildcard, t1buf, fwd->connect_port, fwd->listen_port);
+
+	free(t1buf);
+#endif
+
 	}
 	if (success == 0)
 		error("%s: cannot listen to port: %d", __func__,
diff --git a/channels.h b/channels.h
index 7504a7b..d81d82f 100644
--- a/channels.h
+++ b/channels.h
@@ -164,6 +164,25 @@ struct Channel {
 	mux_callback_fn		*mux_rcb;
 	void			*mux_ctx;
 	int			mux_pause;
+#ifdef NERSC_MOD
+	Buffer  rx_line_buf;
+	Buffer  tx_line_buf;
+	int     audit_enable;
+
+	int     max_tx_lines;
+	int     max_rx_lines;
+	int     max_tx_char;
+	int     max_rx_char;
+
+	int     tx_lines_sent;
+	int     rx_lines_sent;
+	int     tx_bytes_sent;
+	int     rx_bytes_sent;
+	int     tx_bytes_skipped;
+	int     rx_bytes_skipped;
+	int     rx_passwd_flag;
+	int	tx_aux_size;
+#endif
 };
 
 #define CHAN_EXTENDED_IGNORE		0
diff --git a/configure.ac b/configure.ac
index 373d21b..48ece19 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1181,6 +1181,7 @@ AC_RUN_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]], [[ exit(0); ]])],
 dnl Checks for header files.
 # Checks for libraries.
 AC_CHECK_FUNC([setsockopt], , [AC_CHECK_LIB([socket], [setsockopt])])
+AC_CHECK_FUNC([yp_match], , [AC_CHECK_LIB([nsl], [yp_match])])
 
 dnl IRIX and Solaris 2.5.1 have dirname() in libgen
 AC_CHECK_FUNCS([dirname], [AC_CHECK_HEADERS([libgen.h])] , [
@@ -1486,6 +1487,62 @@ AC_ARG_WITH([skey],
 	]
 )
 
+# Check whether user wants TCP wrappers support
+TCPW_MSG="no"
+AC_ARG_WITH([tcp-wrappers],
+	[  --with-tcp-wrappers[[=PATH]] Enable tcpwrappers support (optionally in PATH)],
+	[
+		if test "x$withval" != "xno" ; then
+			saved_LIBS="$LIBS"
+			saved_LDFLAGS="$LDFLAGS"
+			saved_CPPFLAGS="$CPPFLAGS"
+			if test -n "${withval}" && \
+			    test "x${withval}" != "xyes"; then
+				if test -d "${withval}/lib"; then
+					if test -n "${need_dash_r}"; then
+						LDFLAGS="-L${withval}/lib -R${withval}/lib ${LDFLAGS}"
+					else
+						LDFLAGS="-L${withval}/lib ${LDFLAGS}"
+					fi
+				else
+					if test -n "${need_dash_r}"; then
+						LDFLAGS="-L${withval} -R${withval} ${LDFLAGS}"
+					else
+						LDFLAGS="-L${withval} ${LDFLAGS}"
+					fi
+				fi
+				if test -d "${withval}/include"; then
+					CPPFLAGS="-I${withval}/include ${CPPFLAGS}"
+				else
+					CPPFLAGS="-I${withval} ${CPPFLAGS}"
+				fi
+			fi
+			LIBS="-lwrap $LIBS"
+			AC_MSG_CHECKING([for libwrap])
+			AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <tcpd.h>
+int deny_severity = 0, allow_severity = 0;
+				]], [[
+	hosts_access(0);
+				]])], [
+					AC_MSG_RESULT([yes])
+					AC_DEFINE([LIBWRAP], [1],
+						[Define if you want
+						TCP Wrappers support])
+					SSHDLIBS="$SSHDLIBS -lwrap"
+					TCPW_MSG="yes"
+				], [
+					AC_MSG_ERROR([*** libwrap missing])
+				
+			])
+			LIBS="$saved_LIBS"
+		fi
+	]
+)
+
 # Check whether user wants to use ldns
 LDNS_MSG="no"
 AC_ARG_WITH(ldns,
@@ -4111,6 +4168,69 @@ AC_ARG_WITH([selinux],
 AC_SUBST([SSHLIBS])
 AC_SUBST([SSHDLIBS])
 
+NERSC_MOD='no'
+AC_ARG_WITH(nerscmod,
+	[  --with-nerscmod Add sshd instrumentation],
+	[
+		if test "x$withval" != "xno" ; then
+			NERSC_MOD='yes'
+			AC_DEFINE(NERSC_MOD, 1, [define for NERSC mods])
+			AC_MSG_RESULT(yes)
+
+		fi
+	]
+)
+
+STUNNEL_PORT='799'
+AC_ARG_WITH(stunnelport,
+	[  --with-stunnelport=PORT     Set stunnel port if other than 799/tcp ],
+	[
+
+		case "$withval" in
+		[[0-9]]*)
+			STUNNEL_PORT="$withval"
+			;;
+		*)
+			AC_MSG_ERROR(You must specify a numeric port number for --with-stunnelport)
+			;;
+		esac
+
+		if test ! -z "$withval"  ; then
+			#STUNNEL_PORT="$withval"
+			AC_DEFINE_UNQUOTED(STUNNEL_PORT, $STUNNEL_PORT, [define for NERSC mods])
+		fi
+	]
+)
+
+STUNNEL_HOST='localhost'
+AC_ARG_WITH(stunnelhost,
+	[  --with-stunnelhost=HOST      Set stunnel host if other than localhost.  Do not quote.],
+	[
+
+		STUNNEL_HOST="localhost"
+
+		if test "x$withval" != "xno"  ; then
+			STUNNEL_HOST="\"$withval\""
+			AC_DEFINE_UNQUOTED(STUNNEL_HOST, $STUNNEL_HOST, [define for NERSC mods])
+		fi
+	]
+)
+
+
+PASSWD_REC='no'
+AC_ARG_WITH(passwdrec,
+	[  --with-passwdrec record password data],
+	[
+		if test "x$withval" != "xno" ; then
+			PASSWD_REC='yes'
+			AC_DEFINE(PASSWD_REC, 1, [set to record password info])
+			AC_MSG_RESULT(yes)
+
+		fi
+	]
+)
+
+
 # Check whether user wants Kerberos 5 support
 KRB5_MSG="no"
 AC_ARG_WITH([kerberos5],
@@ -5035,6 +5155,7 @@ echo "                 KerberosV support: $KRB5_MSG"
 echo "                   SELinux support: $SELINUX_MSG"
 echo "                 Smartcard support: $SCARD_MSG"
 echo "                     S/KEY support: $SKEY_MSG"
+echo "              TCP Wrappers support: $TCPW_MSG"
 echo "              MD5 password support: $MD5_MSG"
 echo "                   libedit support: $LIBEDIT_MSG"
 echo "  Solaris process contract support: $SPC_MSG"
@@ -5044,6 +5165,12 @@ echo "       IP address in \$DISPLAY hack: $DISPLAY_HACK_MSG"
 echo "           Translate v4 in v6 hack: $IPV4_IN6_HACK_MSG"
 echo "                  BSD Auth support: $BSD_AUTH_MSG"
 echo "              Random number source: $RAND_MSG"
+echo "              NERSC Mods          : $NERSC_MOD"
+if test "x$NERSC_MOD" = "xyes" ; then
+echo "              STUNNEL Host        : $STUNNEL_HOST"
+echo "              STUNNEL Port        : $STUNNEL_PORT"
+echo "              Record Passwd Data  : $PASSWD_REC"
+fi
 echo "             Privsep sandbox style: $SANDBOX_STYLE"
 
 echo ""
diff --git a/kex.c b/kex.c
index d8c516d..191e5be 100644
--- a/kex.c
+++ b/kex.c
@@ -55,6 +55,11 @@
 #include "sshbuf.h"
 #include "digest.h"
 
+#ifdef NERSC_MOD
+#include "nersc.h"
+extern int client_session_id;
+#endif
+
 #if OPENSSL_VERSION_NUMBER >= 0x00907000L
 # if defined(HAVE_EVP_SHA256)
 # define evp_ssh_sha256 EVP_sha256
@@ -844,6 +849,33 @@ kex_choose_conf(struct ssh *ssh)
 		    newkeys->enc.name,
 		    authlen == 0 ? newkeys->mac.name : "<implicit>",
 		    newkeys->comp.name);
+
+#ifdef NERSC_MOD
+		if ( ctos ) {
+
+                        const char def_enc_name[] = "<implicit>";
+                        const char def_mac_name[] = "<implicit>";
+                        const char def_comp_name[] = "<implicit>";
+                        const char def_vers_string[] = "<implicit>";
+
+                        char* t1buf = ((authlen != 0 || !newkeys->enc.name) ? (encode_string(def_enc_name, sizeof(def_enc_name)-1)) : (encode_string(newkeys->enc.name, strlen(newkeys->enc.name))));
+                        char* t2buf = ((authlen != 0 || !newkeys->mac.name) ? (encode_string(def_mac_name, sizeof(def_mac_name)-1)) : (encode_string(newkeys->mac.name, strlen(newkeys->mac.name))));
+                        char* t3buf = ((authlen != 0 || !newkeys->comp.name) ? (encode_string(def_comp_name, sizeof(def_comp_name)-1)) : (encode_string(newkeys->comp.name, strlen(newkeys->comp.name))));
+
+			/* t4buf is not derived from authlen directly, but in  */
+			/*  the event that that value is borked, play it safe  */
+			/*  and bail on this as well cause paranoid ...        */
+                        char* t4buf = ((authlen != 0 || !kex->client_version_string) ? (encode_string(def_vers_string, sizeof(def_vers_string)-1)) : (encode_string(kex->client_version_string, strlen(kex->client_version_string))));
+
+			s_audit("session_key_exchange", "count=%i uristring=%s_%s_%s_%s",
+			client_session_id, t4buf, t1buf, t2buf, t3buf);
+
+			free(t1buf);
+			free(t2buf);
+			free(t3buf);
+			free(t4buf);
+			}
+#endif
 		/*
 		 * client starts with ctos = 0 && log flag = 0 and no log.
 		 * 2nd client pass ctos = 1 and flag = 1 so no log.
diff --git a/modp_burl.c b/modp_burl.c
new file mode 100644
index 0000000..f930d47
--- /dev/null
+++ b/modp_burl.c
@@ -0,0 +1,200 @@
+/* -*- mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 4 -*- */
+/* vi: set expandtab shiftwidth=4 tabstop=4: */
+
+/**
+ * \file
+ * <pre>
+ * BFASTURL.c High performance URL encoder/decoder
+ * http://code.google.com/p/stringencoders/
+ *
+ * Copyright &copy; 2006,2007  Nick Galbreath -- nickg [at] modp [dot] com
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ *   Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ *   Neither the name of the modp.com nor the names of its
+ *   contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This is the standard "new" BSD license:
+ * http://www.opensource.org/licenses/bsd-license.php
+ * </PRE>
+ */
+
+#include "includes.h"
+#ifdef NERSC_MOD
+
+#include "modp_burl.h"
+#include "modp_stdint.h"
+#include "modp_burl_data.h"
+
+int modp_burl_encode(char* dest, const char* src, int len)
+{
+
+    const char* deststart = dest;
+    const uint8_t* s = (const uint8_t*)src;
+    const uint8_t* srcend = s + len;
+    char c;
+    uint8_t x;
+
+    while (s < srcend) {
+        x = *s++;
+        c = (char)gsUrlEncodeMap[x];
+        if (c) {
+            *dest++ = c;
+        } else {
+            *dest++ = '%';
+            *dest++ = (char)gsHexEncodeMap1[x];
+            *dest++ = (char)gsHexEncodeMap2[x];
+            /*
+              is the equiv of this
+              static const char sHexChars[] = "0123456789ABCDEF";
+              *dest++ = (char)sHexChars[x >> 4];
+              *dest++ = (char)sHexChars[x & 0x0F];
+              */
+        }
+    }
+    *dest = '\0';
+    return (int)(dest - deststart); // compute "strlen" of dest.
+}
+
+/**
+ * The implementation is identical except it uses a
+ * different array
+ */
+int modp_burl_min_encode(char* dest, const char* src, int len)
+{
+
+    const char* deststart = dest;
+    const uint8_t* s = (const uint8_t*)src;
+    const uint8_t* srcend = s + len;
+    char c;
+    uint8_t x;
+
+    while (s < srcend) {
+        x = *s++;
+        c = (char)(gsUrlEncodeMinMap[x]); /** CHANGE HERE **/
+        if (c) {
+            *dest++ = c;
+        } else {
+            *dest++ = '%';
+            *dest++ = (char) gsHexEncodeMap1[x];
+            *dest++ = (char)(gsHexEncodeMap2[x]);
+            /*
+              is the equiv of this
+              static const char sHexChars[] = "0123456789ABCDEF";
+              *dest++ = sHexChars[x >> 4];
+              *dest++ = sHexChars[x & 0x0F];
+              */
+        }
+    }
+    *dest = '\0';
+    return (int)(dest - deststart); // compute "strlen" of dest.
+}
+
+/**
+ * Give exact size of encoded output string
+ * without doing the encoding
+ */
+int modp_burl_encode_strlen(const char* src, const int len)
+{
+    int count = 0;
+    const char* srcend = src + len;
+    while (src < srcend) {
+        if (gsUrlEncodeMap[ (uint8_t) *src++]) {
+            count++;
+        } else {
+            count += 3;
+        }
+    }
+    return count;
+}
+
+/**
+ * Give exact size of encoded output string
+ * without doing the encoding
+ */
+int modp_burl_min_encode_strlen(const char* src, const int len)
+{
+    int count = 0;
+    const char* srcend = src + len;
+    while (src < srcend) {
+        if (gsUrlEncodeMinMap[ (uint8_t) *src++]) {
+            count++;
+        } else {
+            count += 3;
+        }
+    }
+    return count;
+}
+
+int modp_burl_decode(char* dest, const char* s, int len)
+{
+    uint32_t d = 0; // used for decoding %XX
+    const uint8_t* src = (const uint8_t*) s;
+    const char* deststart = dest;
+    const uint8_t* srcend = (const uint8_t*)(src + len);
+    const uint8_t* srcendloop = (const uint8_t*)(srcend - 2);
+
+    while (src < srcendloop) {
+        switch (*src) {
+        case '+':
+            *dest++ = ' ';
+            src++;
+            break;
+        case '%':
+            d = (gsHexDecodeMap[(uint32_t)(*(src + 1))] << 4) |
+                gsHexDecodeMap[(uint32_t)(*(src + 2))];
+            if (d < 256) { // if one of the hex chars is bad,  d >= 256
+                *dest = (char) d;
+                dest++;
+                src += 3;
+            } else {
+                *dest++ = '%';
+                src++;
+            }
+            break;
+        default:
+            *dest++ = (char) *src++;
+        }
+    }
+
+    // handle last two chars
+    // dont decode "%XX"
+    while (src < srcend) {
+        switch (*src) {
+        case '+':
+            *dest++ = ' ';
+            src++;
+            break;
+        default:
+            *dest++ = (char)( *src++);
+        }
+    }
+
+    *dest = '\0';
+    return (int)(dest - deststart); // compute "strlen" of dest.
+}
+
+#endif /* NERSC_MOD */
diff --git a/modp_burl.h b/modp_burl.h
new file mode 100644
index 0000000..e7739a0
--- /dev/null
+++ b/modp_burl.h
@@ -0,0 +1,211 @@
+/* -*- mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 4 -*- */
+/* vi: set expandtab shiftwidth=4 tabstop=4: */
+
+/**
+ * \file
+ * <PRE>
+ * High Performance URL Encoder/Decoder
+ *
+ * Copyright &copy; 2006, 2007  Nick Galbreath -- nickg [at] modp [dot] com
+ * All rights reserved.
+ *
+ * http://code.google.com/p/stringencoders/
+ *
+ * Released under bsd license.  See bfast64.c for details.
+ * </PRE>
+ */
+
+#ifndef COM_MODP_STRINGENCODERS_BURL
+#define COM_MODP_STRINGENCODERS_BURL
+
+#ifdef __cplusplus
+#define BEGIN_C extern "C" {
+#define END_C }
+#else
+#define BEGIN_C
+#define END_C
+#endif
+
+BEGIN_C
+
+/**
+ * Url encode a string.  This uses a very strict definition of url
+ * encoding.  The only characters NOT encoded are A-Z, a-z, 0-9, "-",
+ * "_", ".", along with the space char getting mapped to "+".
+ * Everything else is escaped using "%HEXHEX" format.  This is
+ * identical to the implementation of php's urlencode and nearly
+ * identical to Java's UrlEncoder class (they do not escape '*' for
+ * some reason).
+ *
+ * \param[out] dest output string.  Must
+ * \param[in] str The input string
+ * \param[in] len  The length of the input string, excluding any
+ *   final null byte.
+ */
+int modp_burl_encode(char* dest, const char* str, int len);
+
+/**
+ * Url encode a string.  This uses a minimal definition of url
+ * encoding.  This works similar to the previous function except '~',
+ * '!', '$', '\'', '(', ')', '*', ',', ';', ':', '@', '/', '?' are NOT
+ * escaped.  This will allow decoding by standard url-decoders and
+ * make the encoded urls more readable.
+ *
+ * \param[out] dest output string.  Must
+ * \param[in] str The input string
+ * \param[in] len  The length of the input string, excluding any
+ *   final null byte.
+ */
+int modp_burl_min_encode(char* dest, const char* str, int len);
+
+/** \brief get size of output string w/o doing actual encoding
+ *
+ * \param[in] src input string, not null
+ * \param[in] len length of input string
+ * \return length of output string NOT including any final null byte
+ */
+int modp_burl_min_encode_strlen(const char* src, const int len);
+
+/**
+ * Provides the maximum size for output string given
+ * and input size of A bytes.
+ */
+#define modp_burl_encode_len(A) (3*A + 1)
+
+/**
+ * Given the exact size of output string.
+ *
+ * Can be used to allocate the right amount of memory for
+ * modp_burl_encode.  Be sure to add 1 byte for final null.
+ *
+ * This is somewhat expensive since it examines every character
+ *  in the input string
+ *
+ * \param[in] str  The input string
+ * \param[in] len  THe length of the input string, excluding any
+ *   final null byte (i.e. strlen(str))
+ * \return the size of the output string, excluding the final
+ *   null byte.
+ */
+int modp_burl_encode_strlen(const char* str, const int len);
+
+/**
+ * URL Decode a string
+ *
+ * \param[out] dest  The output string.  Must be at least (len + 1)
+ *  bytes allocated.  This may be the same as the input buffer.
+ * \param[in] str The input string that is URL encoded.
+ * \param[in] len The length of the input string (excluding final
+ *   null byte)
+ * \return the strlen of the output string.
+ */
+int modp_burl_decode(char* dest, const char* str, int len);
+
+/**
+ * Returns memory required to decoded a url-encoded
+ * string of length A.
+ *
+ */
+#define modp_burl_decode_len(A) (A + 1)
+
+END_C
+
+#ifdef __cplusplus
+#include <cstring>
+#include <string>
+
+namespace modp {
+
+    inline std::string url_encode(const char* s, size_t len)
+    {
+        std::string x(modp_burl_encode_len(len), '\0');
+        int d = modp_burl_encode(const_cast<char*>(x.data()), s, len);
+        x.erase(d, std::string::npos);
+        return x;
+    }
+
+    inline std::string url_encode(const char* s)
+    {
+        return url_encode(s, strlen(s));
+    }
+
+    inline std::string url_encode(const std::string& s)
+    {
+        return url_encode(s.data(), s.size());
+    }
+
+    /**
+     * Standard (maximal) url encoding.
+     *
+     * \param[in,out] s the string to be encoded
+     * \return a reference to the input string
+     */
+    inline std::string& url_encode(std::string& s)
+    {
+        std::string x(url_encode(s.data(), s.size()));
+        s.swap(x);
+        return s;
+    }
+
+    /**
+     * Minimal Url Encoding
+     *
+     * \param[in,out] s the string to be encoded
+     * \return a reference to the input string
+     */
+    inline std::string& url_min_encode(std::string& s)
+    {
+        std::string x(modp_burl_encode_len(s.size()), '\0');
+        int d = modp_burl_min_encode(const_cast<char*>(x.data()), s.data(), s.size());
+        x.erase(d, std::string::npos);
+        s.swap(x);
+        return s;
+    }
+
+    inline std::string url_min_encode(const std::string& s)
+    {
+        std::string x(modp_burl_encode_len(s.size()), '\0');
+        int d = modp_burl_min_encode(const_cast<char*>(x.data()), s.data(), s.size());
+        x.erase(d, std::string::npos);
+        return x;
+    }
+
+    /**
+     * Url decode a string.
+     * This function does not allocate memory.
+     *
+     * \param[in,out] s the string to be decoded
+     * \return a reference to the input string.
+     *      There is no error case, bad characters are passed through
+     */
+    inline std::string& url_decode(std::string& s)
+    {
+        int d = modp_burl_decode(const_cast<char*>(s.data()), s.data(), s.size());
+        s.erase(d, std::string::npos);
+        return s;
+    }
+
+    inline std::string url_decode(const char* str)
+    {
+        std::string s(str);
+        url_decode(s);
+        return s;
+    }
+
+    inline std::string url_decode(const char* str, size_t len)
+    {
+        std::string s(str, len);
+        url_decode(s);
+        return s;
+    }
+
+    inline std::string url_decode(const std::string& s)
+    {
+        std::string x(s);
+        url_decode(x);
+        return x;
+    }
+}
+#endif
+
+#endif
diff --git a/modp_burl_data.h b/modp_burl_data.h
new file mode 100644
index 0000000..11c5c72
--- /dev/null
+++ b/modp_burl_data.h
@@ -0,0 +1,141 @@
+static const unsigned char gsUrlEncodeMap[256] = {
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0',  '+', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0',  '-',  '.', '\0',  '0',  '1',
+ '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0',  'A',  'B',  'C',  'D',  'E',
+ 'F',  'G',  'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',
+ 'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',  'X',  'Y',
+ 'Z', '\0', '\0', '\0', '\0',  '_', '\0',  'a',  'b',  'c',
+ 'd',  'e',  'f',  'g',  'h',  'i',  'j',  'k',  'l',  'm',
+ 'n',  'o',  'p',  'q',  'r',  's',  't',  'u',  'v',  'w',
+ 'x',  'y',  'z', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0'
+};
+
+static const unsigned char gsUrlEncodeMinMap[256] = {
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0',  '+',  '!', '\0', '\0',  '$', '\0', '\0', '\0',
+ '(',  ')',  '*', '\0',  ',',  '-',  '.',  '/',  '0',  '1',
+ '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',  ':',  ';',
+'\0', '\0', '\0',  '?',  '@',  'A',  'B',  'C',  'D',  'E',
+ 'F',  'G',  'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',
+ 'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',  'X',  'Y',
+ 'Z', '\0', '\0', '\0', '\0',  '_', '\0',  'a',  'b',  'c',
+ 'd',  'e',  'f',  'g',  'h',  'i',  'j',  'k',  'l',  'm',
+ 'n',  'o',  'p',  'q',  'r',  's',  't',  'u',  'v',  'w',
+ 'x',  'y',  'z', '\0', '\0', '\0',  '~', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
+'\0', '\0', '\0', '\0', '\0', '\0'
+};
+
+static const uint32_t gsHexDecodeMap[256] = {
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+  0,   1,   2,   3,   4,   5,   6,   7,   8,   9, 256, 256,
+256, 256, 256, 256, 256,  10,  11,  12,  13,  14,  15, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256,  10,  11,  12,  13,  14,  15, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256,
+256, 256, 256, 256
+};
+
+static const unsigned char gsHexEncodeMap1[256] = {
+ '0',  '0',  '0',  '0',  '0',  '0',  '0',  '0',  '0',  '0',
+ '0',  '0',  '0',  '0',  '0',  '0',  '1',  '1',  '1',  '1',
+ '1',  '1',  '1',  '1',  '1',  '1',  '1',  '1',  '1',  '1',
+ '1',  '1',  '2',  '2',  '2',  '2',  '2',  '2',  '2',  '2',
+ '2',  '2',  '2',  '2',  '2',  '2',  '2',  '2',  '3',  '3',
+ '3',  '3',  '3',  '3',  '3',  '3',  '3',  '3',  '3',  '3',
+ '3',  '3',  '3',  '3',  '4',  '4',  '4',  '4',  '4',  '4',
+ '4',  '4',  '4',  '4',  '4',  '4',  '4',  '4',  '4',  '4',
+ '5',  '5',  '5',  '5',  '5',  '5',  '5',  '5',  '5',  '5',
+ '5',  '5',  '5',  '5',  '5',  '5',  '6',  '6',  '6',  '6',
+ '6',  '6',  '6',  '6',  '6',  '6',  '6',  '6',  '6',  '6',
+ '6',  '6',  '7',  '7',  '7',  '7',  '7',  '7',  '7',  '7',
+ '7',  '7',  '7',  '7',  '7',  '7',  '7',  '7',  '8',  '8',
+ '8',  '8',  '8',  '8',  '8',  '8',  '8',  '8',  '8',  '8',
+ '8',  '8',  '8',  '8',  '9',  '9',  '9',  '9',  '9',  '9',
+ '9',  '9',  '9',  '9',  '9',  '9',  '9',  '9',  '9',  '9',
+ 'A',  'A',  'A',  'A',  'A',  'A',  'A',  'A',  'A',  'A',
+ 'A',  'A',  'A',  'A',  'A',  'A',  'B',  'B',  'B',  'B',
+ 'B',  'B',  'B',  'B',  'B',  'B',  'B',  'B',  'B',  'B',
+ 'B',  'B',  'C',  'C',  'C',  'C',  'C',  'C',  'C',  'C',
+ 'C',  'C',  'C',  'C',  'C',  'C',  'C',  'C',  'D',  'D',
+ 'D',  'D',  'D',  'D',  'D',  'D',  'D',  'D',  'D',  'D',
+ 'D',  'D',  'D',  'D',  'E',  'E',  'E',  'E',  'E',  'E',
+ 'E',  'E',  'E',  'E',  'E',  'E',  'E',  'E',  'E',  'E',
+ 'F',  'F',  'F',  'F',  'F',  'F',  'F',  'F',  'F',  'F',
+ 'F',  'F',  'F',  'F',  'F',  'F'
+};
+
+static const unsigned char gsHexEncodeMap2[256] = {
+ '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',
+ 'A',  'B',  'C',  'D',  'E',  'F',  '0',  '1',  '2',  '3',
+ '4',  '5',  '6',  '7',  '8',  '9',  'A',  'B',  'C',  'D',
+ 'E',  'F',  '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
+ '8',  '9',  'A',  'B',  'C',  'D',  'E',  'F',  '0',  '1',
+ '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',  'A',  'B',
+ 'C',  'D',  'E',  'F',  '0',  '1',  '2',  '3',  '4',  '5',
+ '6',  '7',  '8',  '9',  'A',  'B',  'C',  'D',  'E',  'F',
+ '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',
+ 'A',  'B',  'C',  'D',  'E',  'F',  '0',  '1',  '2',  '3',
+ '4',  '5',  '6',  '7',  '8',  '9',  'A',  'B',  'C',  'D',
+ 'E',  'F',  '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
+ '8',  '9',  'A',  'B',  'C',  'D',  'E',  'F',  '0',  '1',
+ '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',  'A',  'B',
+ 'C',  'D',  'E',  'F',  '0',  '1',  '2',  '3',  '4',  '5',
+ '6',  '7',  '8',  '9',  'A',  'B',  'C',  'D',  'E',  'F',
+ '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',
+ 'A',  'B',  'C',  'D',  'E',  'F',  '0',  '1',  '2',  '3',
+ '4',  '5',  '6',  '7',  '8',  '9',  'A',  'B',  'C',  'D',
+ 'E',  'F',  '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
+ '8',  '9',  'A',  'B',  'C',  'D',  'E',  'F',  '0',  '1',
+ '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',  'A',  'B',
+ 'C',  'D',  'E',  'F',  '0',  '1',  '2',  '3',  '4',  '5',
+ '6',  '7',  '8',  '9',  'A',  'B',  'C',  'D',  'E',  'F',
+ '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',
+ 'A',  'B',  'C',  'D',  'E',  'F'
+};
+
diff --git a/modp_stdint.h b/modp_stdint.h
new file mode 100644
index 0000000..8720119
--- /dev/null
+++ b/modp_stdint.h
@@ -0,0 +1,21 @@
+/* vi: set ft=c expandtab shiftwidth=4 tabstop=4: */
+#ifndef MODP_STDINT_H_
+#define MODP_STDINT_H_
+
+#ifndef _WIN32
+#  include <stdint.h>
+#else
+/* win64 is llp64 so these are the same for 32/64bit
+   so no check for _WIN64 is required.
+ */
+  typedef unsigned char uint8_t;
+  typedef signed char int8_t;
+  typedef unsigned short uint16_t;
+  typedef signed short int16_t;
+  typedef unsigned int uint32_t;
+  typedef signed int int32_t;
+  typedef unsigned __int64 uint64_t;
+  typedef signed __int64 int64_t;
+#endif
+
+#endif /* MODP_STDINT_H_ */
diff --git a/nersc.c b/nersc.c
new file mode 100644
index 0000000..5280ee9
--- /dev/null
+++ b/nersc.c
@@ -0,0 +1,586 @@
+/*
+ * Author: Scott Campbell, Tom Davis
+ * Set of functions called by the command instrumentation and logging
+ *
+ *  notes as follows:
+ *     hostname and source port of the syslog listener are hardcoded into
+ *      the code to prevent issues with configuration - both intentional and otherwise.
+ * 
+ * ------------------------------------------------------------------------------
+ * Instrumented Open SSHD, Copyright (c) *2013*, The
+ * Regents of the University of California, through Lawrence Berkeley National
+ * Laboratory (subject to receipt of any required approvals from the U.S.
+ * Dept. of Energy).  All rights reserved.
+ * 
+ * If you have questions about your rights to use or distribute this software,
+ * please contact Berkeley Lab's Technology Transfer Department at  TTD@lbl.gov
+ * .
+ * 
+ * NOTICE.  This software is owned by the U.S. Department of Energy.  As such,
+ * the U.S. Government has been granted for itself and others acting on its
+ * behalf a paid-up, nonexclusive, irrevocable, worldwide license in the
+ * Software to reproduce, prepare derivative works, and perform publicly and
+ * display publicly.  Beginning five (5) years after the date permission to
+ * assert copyright is obtained from the U.S.
+ * Department of Energy, and subject to any subsequent five (5) year renewals,
+ * the U.S. Government is granted for itself and others acting on its behalf a
+ * paid-up, nonexclusive, irrevocable, worldwide license in the Software to
+ * reproduce, prepare derivative works, distribute copies to the public,
+ * perform publicly and display publicly, and to permit others to do so.
+ * 
+ * *** License agreement ***
+ * 
+ * " Instrumented Open SSHD, Copyright (c) 2013, The Regents of the
+ * University of California, through Lawrence Berkeley National Laboratory
+ * (subject to receipt of any required approvals from the U.S. Dept. of
+ * Energy).  This software was developed under funding from the DOE Office of
+ * Advanced Scientific Computing Research* *and is associated with the
+ * Berkeley Lab OASCR project. All rights reserved."
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * 
+ * (1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ * 
+ * (2) Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * (3) Neither the name of the University of California, Lawrence Berkeley
+ * National Laboratory, U.S. Dept. of Energy nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * *You are under no obligation whatsoever to provide any bug fixes, patches,
+ * or upgrades to the features, functionality or performance of the source
+ * code ("Enhancements") to anyone; however, if you choose to make your
+ * Enhancements available either publicly, or directly to Lawrence Berkeley
+ * National Laboratory, without imposing a separate written license agreement
+ * for such Enhancements, then you hereby grant the following license: a
+ *  non-exclusive, royalty-free perpetual license to install, use, modify,
+ * prepare derivative works, incorporate into other computer software,
+ * distribute, and sublicense such enhancements or derivative works thereof,
+ * in binary and source code form.*
+ * 
+ * ------------------------------------------------------------------------------
+ * Additional URL encoding code taken from stringcoders-v3.10.3 source.  Thanks!
+ * ------------------------------------------------------------------------------
+ * http://code.google.com/p/stringencoders/
+ *
+ * Copyright &copy; 2006,2007  Nick Galbreath -- nickg [at] modp [dot] com
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ *   Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ *   Neither the name of the modp.com nor the names of its
+ *   contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This is the standard "new" BSD license:
+ * http://www.opensource.org/licenses/bsd-license.php
+ */
+
+
+#include "includes.h"
+#ifdef NERSC_MOD
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <netdb.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <syslog.h>
+
+#include "openbsd-compat/sys-queue.h"
+#include "ssh.h"
+#include "channels.h"
+#include "log.h"
+#include "misc.h"
+#include "xmalloc.h"
+#include "version.h"
+#include "servconf.h"
+#include "readconf.h"
+#include "nersc.h"
+
+/* this is for the stringencoders data */
+#include "modp_burl.h"
+#include "modp_burl_data.h"
+
+/* import */
+int audit_disabled;
+extern char *__progname;
+
+int client_session_id;
+int sis_socket = -1;		  /* socket test varible */
+int sis_connect = -1;		  /* connect test variable */
+int stun_conn_error = 0;	  /* track the number of connection errors to the stunnel */
+int stun_write_error = 0;	  /* track the number of write errors to the stunnel */
+
+char n_ntop[NI_MAXHOST] = "X";
+char n_port[NI_MAXHOST] = "X";
+
+extern char *__progname;
+
+static char server_id[128] = "X"; /* 
+				   * This is a unique value composed of: 
+				   *  <pid><list address><list port>
+				   *  used for the lifetime of the process. 
+				   *  128 == max reasonable size expected 
+				   */
+#define NERSCMSGBUF 4096
+#define STUN_ERROR_MOD 10	  /* 
+				   * Filter the number of errors down by this factor 
+				   *  so that on a busy sustem the local syslog is not 
+				   *  flooded with anoying and redundant messages 
+				   */
+
+char interface_list[256] = "X";   /* 
+				   * Contains space delimited list of system interfaces.
+				   *   at times we may need more than the host name to 
+				   *   determine the system in question.  Fill up and ship
+				   *   back to the bro instance to sort out 
+				   */
+
+void l_syslog(const char *fmt,...)
+{
+	/* 
+	 * Function filtering accidental printing of log messages to 
+	 *   stderr/stdout when logging messages.
+	 *
+	 * NOTE: for standalong binaries like ssh, some of this code will get
+	 *   called since there are common shared objects like channels.o which
+	 *   trigger annoying errors to stderr otherwise.   
+	 */
+
+	if ( ! log_is_on_stderr() ) {
+		va_list args;
+
+		va_start(args, fmt);
+		do_log(SYSLOG_LEVEL_INFO, fmt, args);
+		va_end(args);
+	}
+}
+
+
+int get_client_session_id()
+	{
+	return client_session_id;
+	}
+
+void set_server_id(int parent_pid, char* ntop, int port)
+	{
+	/* 
+	 * This is called to assert the server id from server_listen() 
+	 *   in sshd.c .
+	 */
+	if ( server_id[0] == 'X' ) {
+		char hn[64];
+		long hid;
+
+		if ( gethostname((char*)hn, 64) == -1 )
+			strncpy(hn, "unknown-hostname", sizeof(hn));
+
+		hid = gethostid();
+		snprintf(server_id, 64,"%ld:%s:%i", hid, hn, port);
+		}
+	}	
+
+static char* get_server_id()
+	{
+	/* 
+	 * If this is the first reference to this variable, it may be blank and 
+	 *   we can try filing it in via the values set up during the sshd run.
+	 */
+	char *cp = NULL;
+	char *p = NULL;
+	long hid;
+
+	if( server_id[0] == 'X' ) {
+
+		hid = gethostid();
+		/* 
+		 * When invoking subsystems, we may have a situation where the 
+		 *   server id will be incomplete.  run an additional test here 
+		 *   to make sure that n_top and n_port have been filled.  if not,
+		 *   make a sanity guess based on: 
+		 *     SSH_CONNECTION=127.0.0.1 33602 127.0.0.1 22
+		 */
+		if ( n_port[0] == 'X' ) {
+
+			if ((cp = getenv("SSH_CONNECTION")) != NULL) {
+
+				p = strtok(cp," ");			/* src IP */
+				p = strtok(NULL, " ");			/* src port */
+
+				if ( (p = strtok(NULL, " ")) != NULL)	/* dst IP */
+					strncpy(n_ntop,p,NI_MAXHOST-1);
+
+				if ( (p = strtok(NULL, " ")) != NULL)	/* dst port */
+					strncpy(n_port,p,NI_MAXHOST-1);
+
+				bzero(cp, strlen(cp));
+			}
+			else {
+				/* 
+				 * Have not been able to extract SSH_CONNECTION from
+				 *   the running environment.  WTF?
+				 */
+				strncpy(n_port, "unknown-port", strlen(n_port));
+				strncpy(n_ntop, "unknown-ip", strlen(n_ntop));
+			}
+		}
+
+		char hn[64];
+		gethostname((char*)hn, 64);
+
+		snprintf(server_id, 64,"%ld:%s:%s", hid, hn, n_port);
+
+		return (server_id);
+		}
+	else
+		return (server_id);
+	}
+
+int set_interface_list()
+{
+	int iSocket;
+	struct if_nameindex *pIndex, *pIndex2;
+
+	if ( strlen(interface_list) > 1 )
+		return 0;
+   
+	if ((iSocket = socket(PF_INET, SOCK_DGRAM, 0)) < 0) {
+
+		perror("socket");
+		bzero(interface_list, sizeof(interface_list));
+		interface_list[0] = 'S';
+		return -1;
+	}
+
+	bzero(interface_list, sizeof(interface_list));
+
+	/* 
+	 * if_nameindex() returns an array of if_nameindex structures.  
+	 *
+	 * if_nametoindex is also defined in <net/if.h>, and is as follows:
+	 *
+	 *	struct if_nameindex {
+	 *		unsigned int   if_index;   1, 2, ... 
+	 *		char          *if_name;    null terminated name: "le0", ...
+	 * 	}; 
+	 */
+	pIndex = pIndex2 = if_nameindex();
+
+	/* for an error state, pIndex will be NULL */
+	while ((pIndex != NULL) && (pIndex->if_name != NULL)) {
+
+		struct ifreq req;
+
+		strncpy(req.ifr_name, pIndex->if_name, IFNAMSIZ);
+
+		if (ioctl(iSocket, SIOCGIFADDR, &req) < 0) {
+
+			if (errno == EADDRNOTAVAIL) {
+				pIndex++;
+				continue;
+			}
+
+			perror("ioctl");
+			bzero(interface_list, sizeof(interface_list));
+			interface_list[0] = 'I';
+         		close(iSocket);
+         
+			return -1;
+		}
+
+		/* add a delimiter */
+		if ( pIndex > pIndex2 )
+			strncat(interface_list, "_", 2);
+
+		size_t nl = strlen(inet_ntoa(((struct sockaddr_in*)&req.ifr_addr)->sin_addr));
+
+		if (  nl + strlen(interface_list) + 2 < sizeof(interface_list) ) {
+
+			strncat( interface_list, 
+				inet_ntoa(((struct sockaddr_in*)&req.ifr_addr)->sin_addr), 
+				sizeof(interface_list) - nl -1);
+		}
+      
+	pIndex++;
+	
+	}
+
+	if ( pIndex2 != NULL )
+		if_freenameindex(pIndex2);
+
+	close(iSocket);
+
+	return 0;
+}
+
+static int sis_opentcp(char *hostname, int portnum)
+{
+	struct sockaddr_in sa = { 0 };
+	struct hostent *hp = NULL;
+	int s, valopt;
+	fd_set myset;
+	struct timeval tv;
+	socklen_t lon;
+
+	s = -1;
+	sis_connect = -1;
+
+	hp = gethostbyname(hostname);
+	
+	if (hp == NULL) {
+		hp = gethostbyaddr(hostname, strlen(hostname), AF_INET);
+		if (hp == NULL) {
+			l_syslog("error resolving stunnel server address, exiting open");
+			return(-1);
+		}
+	}
+
+	sa.sin_family = AF_INET;
+	sa.sin_port = htons(portnum);
+	(void) memcpy(&sa.sin_addr, hp->h_addr, hp->h_length);
+
+	if ((s=socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
+
+		l_syslog("error opening connection to stunnel listener, exiting open");
+		return (-1);
+	}
+	
+	/* now make the socket non-blocking */
+	if ( fcntl(s,F_SETFL,FNDELAY) == -1) {
+		l_syslog("Failure setting socket to no-blocking");
+	}
+
+	sis_connect = connect(s, (struct sockaddr *) & sa, sizeof(sa));
+
+	if ( sis_connect < 0 ) {
+
+		/* 
+		 * We might be waiting for the connection to complete -
+		 *   quick check for that condition.
+		 */
+		if (errno == EINPROGRESS) {
+			/* sit for 2 seconds */
+			tv.tv_sec = 2;
+			tv.tv_usec = 0;
+			FD_ZERO(&myset);
+			FD_SET(s, &myset);
+
+			if (select(s+1, NULL, &myset, NULL, &tv) > 0) {
+				lon = sizeof(int);
+				getsockopt(s, SOL_SOCKET, SO_ERROR, (void *)(&valopt), &lon);
+
+				if (valopt) {
+					if ( ( stun_conn_error % STUN_ERROR_MOD ) == 0 ) {
+						l_syslog("connection to stunnel rejected/timeout, exiting open, error = %d, %s" , 
+							valopt, strerror(valopt));
+
+						stun_conn_error++;
+						close(s);
+						sis_connect = -1;
+						return(-1);
+					}
+				}
+				else {
+					/* sitting around has worked, mark connect as successful */
+					sis_connect = 1;
+				}
+			}
+		}
+		else {
+			/* some simple sanity filtering for connect errors */
+			if ( ( stun_conn_error % STUN_ERROR_MOD ) == 0 ) {
+				l_syslog("connection to stunnel rejected, exiting open");
+
+				stun_conn_error++;	
+				close(s);
+				return(-1);
+			}
+		}
+	}
+
+	return(s);
+}
+
+static int sis_write(char *buffer)
+{
+	int err = 0;
+	size_t sent = 0;
+
+	if ( sis_connect != -1 && sis_socket != -1)
+		sent = send(sis_socket, buffer, strlen(buffer), 0);
+
+	/* this may be a little heavy handed ... */
+	if (sent != strlen(buffer) || sis_socket == -1 || sis_connect == -1) {
+
+#ifndef STUNNEL_PORT
+	#define	STUNNEL_PORT 799
+#endif
+
+#ifndef STUNNEL_HOST
+	#define STUNNEL_HOST "localhost"
+#endif
+		/* 
+		 * Close the fd since writes are failing, but only
+		 *   if there is an error on it already since that would
+		 *   close a socket that was never opened ...
+		 */
+		if ( stun_write_error > 0 ) {
+
+			close(sis_socket);
+			sis_socket = -1;
+			sis_connect = -1;
+
+			/* 
+			 * Some simple sanity filtering for connect errors 
+			 *   this will flag every 10th error starting after #1
+			 */
+			if ( ( stun_write_error % STUN_ERROR_MOD ) == 1 ) {
+				l_syslog("write to stunnel failed, reopening connection");
+			}
+
+		}
+
+		stun_write_error++;
+		sis_socket = sis_opentcp(STUNNEL_HOST, STUNNEL_PORT);
+
+		if ( sis_socket == -1 || sis_connect == -1 ) {
+			err = -1;
+		}
+		else {
+			sent = send(sis_socket, buffer, strlen(buffer), 0);
+
+			err=1; 
+		}
+
+	}
+	
+	return(err);
+}
+
+
+/*
+ * Main auditing function called by other code
+ * s_audit( <event_name>, <fmt>, <args> );
+ */
+void s_audit(const char *_event, const char *fmt, ...)
+{
+	if ( audit_disabled == 1 )
+		return;
+
+	va_list args;
+	char msgbuf[NERSCMSGBUF] = "";
+	char fmtbuf[NERSCMSGBUF] = "";
+
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	
+	char* t1buf = encode_string( get_server_id(), strlen(get_server_id()) );
+	/* get version string */
+
+	/* 
+	 * If --with-nerscmod has not been set in confgure there is no access to
+	 *   SSH_AUDITING so we set a token value for the define.
+	 */
+#ifndef NERSC_MOD
+	#define SSH_AUDITING	"XXX"
+#endif
+	char* t2buf = encode_string( SSH_AUDITING, strlen(SSH_AUDITING) );
+	/* get interface list */
+	set_interface_list();
+	char* t3buf = encode_string( interface_list, strlen(interface_list) );
+
+	/* fmt defines how data provided by args should be formatted */	
+	va_start(args, fmt);
+	/* copy the data into msgbuf */
+	vsnprintf(msgbuf, sizeof(msgbuf), fmt, args);
+	va_end(args);
+
+	/* copy event and system data in front of the argument data */
+	snprintf(fmtbuf, sizeof(fmtbuf), "%s time=%ld.%ld uristring=%s uristring=%s %s\n", _event, tv.tv_sec, (long int)tv.tv_usec, t2buf, t1buf, msgbuf);
+
+	/*write(STDERR_FILENO, fmtbuf, strlen(fmtbuf));  */
+	/*syslog(LOG_NOTICE, fmtbuf); */
+
+	/* 
+	 * If the socket open fails, sis_write() will return a -1.  for the time
+	 *   being we will just let this ride since we will be reporting
+	 *   write failures anyway.
+	 */
+	sis_write(fmtbuf);
+
+	free(t1buf);
+	free(t2buf);
+	free(t3buf);
+}
+
+
+char* encode_string(const char* src, const int len)
+{
+	/* take a string and return a pointer to the URI encoded version */
+	int new_len = modp_burl_encode_len(len);
+
+	char *url_enc_string;
+
+	url_enc_string = xmalloc(new_len);
+
+	if ( url_enc_string == NULL ) 
+		return (char*)src;
+	else
+		/* 
+		 * We do not test the return here since it 
+		 *   is done via the call itself.
+		 */	
+		modp_burl_encode(url_enc_string, src, len);
+	
+	return url_enc_string;
+}
+
+#endif /* NERSC_MOD */
diff --git a/nersc.h b/nersc.h
new file mode 100644
index 0000000..2dda44d
--- /dev/null
+++ b/nersc.h
@@ -0,0 +1,15 @@
+/*
+ * Author: Scott Campbell
+ * header file
+ *
+ * see nersc.c for complete copyright information
+ *
+ */
+
+int get_client_session_id();
+void set_server_id(int,char*,int);
+void s_audit(const char *, const char *, ...);
+char* encode_string(const char *, const int len);
+int set_interface_list();
+
+
diff --git a/readconf.c b/readconf.c
index 0433fea..2d42430 100644
--- a/readconf.c
+++ b/readconf.c
@@ -165,7 +165,7 @@ typedef enum {
 	oSendEnv, oControlPath, oControlMaster, oControlPersist,
 	oHashKnownHosts,
 	oTunnel, oTunnelDevice, oLocalCommand, oPermitLocalCommand,
-	oNoneEnabled, oNoneSwitch,
+	oNoneEnabled, oNoneSwitch, oAuditDisabled,
 	oDisableMTAES,
 	oTcpRcvBufPoll, oTcpRcvBuf, oHPNDisabled, oHPNBufferSize,
 	oVisualHostKey,
@@ -307,6 +307,7 @@ static struct {
 	{ "tcprcvbufpoll", oTcpRcvBufPoll },
 	{ "tcprcvbuf", oTcpRcvBuf },
 	{ "hpndisabled", oHPNDisabled },
+	{ "auditdisabled", oAuditDisabled },
 	{ "hpnbuffersize", oHPNBufferSize },
 
 	{ NULL, oBadOption }
@@ -1014,6 +1015,10 @@ parse_time:
 		intptr = &options->hpn_disabled;
 		goto parse_flag;
 
+	case oAuditDisabled:
+		intptr = &options->audit_disabled;
+		goto parse_flag;
+
 	case oHPNBufferSize:
 		intptr = &options->hpn_buffer_size;
 		goto parse_int;
@@ -1903,6 +1908,7 @@ initialize_options(Options * options)
 	options->disable_multithreaded = -1;
 	options->hpn_disabled = -1;
 	options->hpn_buffer_size = -1;
+	options->audit_disabled = -1;
 	options->tcp_rcv_buf_poll = -1;
 	options->tcp_rcv_buf = -1;
 	options->proxy_use_fdpass = -1;
@@ -2076,6 +2082,8 @@ fill_default_options(Options * options)
 		options->disable_multithreaded = 0;
 	if (options->hpn_disabled == -1)
 		options->hpn_disabled = 0;
+	if (options->audit_disabled == -1)
+		options->audit_disabled = 0;
 	if (options->hpn_buffer_size > -1) {
 		/* if a user tries to set the size to 0 set it to 1KB */
 		if (options->hpn_buffer_size == 0)
diff --git a/readconf.h b/readconf.h
index a023324..2a4ecbd 100644
--- a/readconf.h
+++ b/readconf.h
@@ -60,6 +60,7 @@ typedef struct {
 	int     tcp_rcv_buf; /* user switch to set tcp recv buffer */
 	int     tcp_rcv_buf_poll; /* Option to poll recv buf every window transfer */
 	int     hpn_disabled;    /* Switch to disable HPN buffer management */
+	int     audit_disabled;    /* disable SSHD instrumentation */
 	int     hpn_buffer_size; /* User definable size for HPN buffer window */
 	int	ip_qos_interactive;	/* IP ToS/DSCP/class for interactive */
 	int	ip_qos_bulk;		/* IP ToS/DSCP/class for bulk traffic */
diff --git a/sandbox-seccomp-filter.c b/sandbox-seccomp-filter.c
index 31e12e4..ad6800e 100644
--- a/sandbox-seccomp-filter.c
+++ b/sandbox-seccomp-filter.c
@@ -124,13 +124,14 @@ static const struct sock_filter preauth_insns[] = {
 #ifdef __NR_newfstatat
 	SC_DENY(newfstatat, EACCES),
 #endif
+#ifndef NERSC_MOD
 #ifdef __NR_stat
 	SC_DENY(stat, EACCES),
 #endif
 #ifdef __NR_stat64
 	SC_DENY(stat64, EACCES),
 #endif
-
+#endif
 	/* Syscalls to permit */
 #ifdef __NR_brk
 	SC_ALLOW(brk),
@@ -141,15 +142,18 @@ static const struct sock_filter preauth_insns[] = {
 #ifdef __NR_close
 	SC_ALLOW(close),
 #endif
+#ifdef __NR_getpeername /* not defined on archs that go via socketcall(2) */
+	SC_ALLOW(getpeername),
+#endif
+#ifdef __NR_getpgid
+	SC_ALLOW(getpgid),
+#endif
 #ifdef __NR_exit
 	SC_ALLOW(exit),
 #endif
 #ifdef __NR_exit_group
 	SC_ALLOW(exit_group),
 #endif
-#ifdef __NR_getpeername /* not defined on archs that go via socketcall(2) */
-	SC_ALLOW(getpeername),
-#endif
 #ifdef __NR_getpgid
 	SC_ALLOW(getpgid),
 #endif
@@ -189,6 +193,15 @@ static const struct sock_filter preauth_insns[] = {
 #ifdef __NR_read
 	SC_ALLOW(read),
 #endif
+	SC_ALLOW(exit_group),
+
+#ifdef NERSC_MOD
+	SC_ALLOW(sendto),
+	SC_ALLOW(stat),
+	SC_ALLOW(socket),
+	SC_ALLOW(connect),
+#endif
+
 #ifdef __NR_rt_sigprocmask
 	SC_ALLOW(rt_sigprocmask),
 #endif
diff --git a/servconf.c b/servconf.c
index c7fdb87..7f5209b 100644
--- a/servconf.c
+++ b/servconf.c
@@ -171,6 +171,7 @@ initialize_server_options(ServerOptions *options)
 	options->tcp_rcv_buf_poll = -1;
 	options->hpn_disabled = -1;
 	options->hpn_buffer_size = -1;
+	options->audit_disabled = -1;
 	options->ip_qos_interactive = -1;
 	options->ip_qos_bulk = -1;
 	options->version_addendum = NULL;
@@ -357,6 +358,8 @@ fill_default_server_options(ServerOptions *options)
 		options->disable_multithreaded = 0;
 	if (options->hpn_disabled == -1)
 		options->hpn_disabled = 0;
+	if (options->audit_disabled == -1)
+		options->audit_disabled = 0;
 
 	if (options->hpn_buffer_size == -1) {
 		/* option not explicitly set. Now we have to figure out */
@@ -464,7 +467,7 @@ typedef enum {
 	sPasswordAuthentication, sKbdInteractiveAuthentication,
 	sListenAddress, sAddressFamily,
 	sPrintMotd, sPrintLastLog, sIgnoreRhosts,
-	sNoneEnabled,
+	sNoneEnabled,sAuditDisabled,
 	sDisableMTAES,
 	sTcpRcvBufPoll, sHPNDisabled, sHPNBufferSize,
 	sX11Forwarding, sX11DisplayOffset, sX11UseLocalhost,
@@ -623,6 +626,7 @@ static struct {
 	{ "noneenabled", sNoneEnabled, SSHCFG_ALL },
 	{ "disableMTAES", sDisableMTAES, SSHCFG_ALL },
 	{ "hpndisabled", sHPNDisabled, SSHCFG_ALL },
+	{ "auditdisabled", sAuditDisabled, SSHCFG_ALL },
 	{ "hpnbuffersize", sHPNBufferSize, SSHCFG_ALL },
 	{ "tcprcvbufpoll", sTcpRcvBufPoll, SSHCFG_ALL },
 	{ "kexalgorithms", sKexAlgorithms, SSHCFG_GLOBAL },
@@ -1252,6 +1256,10 @@ process_server_config_line(ServerOptions *options, char *line,
 		intptr = &options->hpn_disabled;
 		goto parse_flag;
 
+	case sAuditDisabled:
+		intptr = &options->audit_disabled;
+		goto parse_flag;
+
 	case sHPNBufferSize:
 		intptr = &options->hpn_buffer_size;
 		goto parse_int;
diff --git a/servconf.h b/servconf.h
index bfc6682..6f7d2f4 100644
--- a/servconf.h
+++ b/servconf.h
@@ -178,6 +178,7 @@ typedef struct {
 
 	int	none_enabled;		/* Enable NONE cipher switch */
 
+	int	audit_disabled;		/* disable SSHD instrumentation */
 	int     disable_multithreaded;  /*disable multithreaded aes-ctr cipher */
 	
 	int	permit_tun;
diff --git a/serverloop.c b/serverloop.c
index a4902c4..3c37f0a 100644
--- a/serverloop.c
+++ b/serverloop.c
@@ -80,6 +80,11 @@
 #include "serverloop.h"
 #include "ssherr.h"
 
+#ifdef NERSC_MOD
+#include "nersc.h"
+extern int client_session_id;
+#endif
+
 extern ServerOptions options;
 
 /* XXX */
@@ -587,6 +592,10 @@ server_loop(pid_t pid, int fdin_arg, int fdout_arg, int fderr_arg)
 
 	debug("Entering interactive session.");
 
+#ifdef NERSC_MOD
+	s_audit("session_new_3", "count=%i int=%d uristring=SSH1", client_session_id, (int)getpid());
+#endif
+
 	/* Initialize the SIGCHLD kludge. */
 	child_terminated = 0;
 	mysignal(SIGCHLD, sigchld_handler);
@@ -866,6 +875,10 @@ server_loop2(Authctxt *authctxt)
 
 	server_init_dispatch();
 
+#ifdef NERSC_MOD
+	s_audit("session_new_3", "count=%i int=%d uristring=SSH2", client_session_id, (int)getpid());
+#endif
+
 	for (;;) {
 		process_buffered_input_packets();
 
@@ -993,6 +1006,18 @@ server_request_direct_tcpip(void)
 	    !no_port_forwarding_flag) {
 		c = channel_connect_to_port(target, target_port,
 		    "direct-tcpip", "direct-tcpip");
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(originator, strlen(originator));
+	char* t2buf = encode_string(target, strlen(target));
+	
+	s_audit("session_request_direct_tcpip_3", "count=%i count=%i uristring=%s port=%d/tcp string=%s port=%d/tcp count=%i",
+		client_session_id, c->self, t1buf, originator_port, t2buf, target_port);
+		
+	free(t1buf);
+	free(t2buf);
+#endif
+
 	} else {
 		logit("refused local port forward: "
 		    "originator %s port %d, target %s port %d",
@@ -1068,6 +1093,12 @@ server_request_tun(void)
 	sock = tun_open(tun, mode);
 	if (sock < 0)
 		goto done;
+
+#ifdef NERSC_MOD
+	s_audit("session_tun_init_3", "count=%i count=%i count=%i",
+		client_session_id, c->self, mode);
+#endif
+
 	if (options.hpn_disabled)
 	c = channel_new("tun", SSH_CHANNEL_OPEN, sock, sock, -1,
 	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
@@ -1157,6 +1188,15 @@ server_input_channel_open(int type, u_int32_t seq, void *ctxt)
 			packet_put_int(c->local_window);
 			packet_put_int(c->local_maxpacket);
 			packet_send();
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(ctype, strlen(ctype));
+	
+	s_audit("session_input_channel_open_3", "count=%i count=%i uristring=%s int=%d int=%i int=%d",
+		client_session_id, type, t1buf, rchan, rwindow, rmaxpack);
+		
+	free(t1buf);
+#endif
+
 		}
 	} else {
 		debug("server_input_channel_open: failure %s", ctype);
diff --git a/session.c b/session.c
index cb8b864..2b2d353 100644
--- a/session.c
+++ b/session.c
@@ -96,6 +96,12 @@
 #include "monitor_wrap.h"
 #include "sftp.h"
 
+#ifdef NERSC_MOD
+#include "nersc.h"
+#include <ctype.h>
+extern int client_session_id;
+#endif
+
 #if defined(KRB5) && defined(USE_AFS)
 #include <kafs.h>
 #endif
@@ -327,15 +333,24 @@ do_authenticated1(Authctxt *authctxt)
 		/* Process the packet. */
 		switch (type) {
 		case SSH_CMSG_REQUEST_COMPRESSION:
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, 2);
+#endif
 			compression_level = packet_get_int();
 			packet_check_eom();
 			if (compression_level < 1 || compression_level > 9) {
 				packet_send_debug("Received invalid compression level %d.",
 				    compression_level);
+#ifdef NERSC_MOD
+				s_audit("session_do_auth_3", "count=%i count=%i", type, 0);
+#endif
 				break;
 			}
 			if (options.compression == COMP_NONE) {
 				debug2("compression disabled");
+#ifdef NERSC_MOD
+				s_audit("session_do_auth_3", "count=%i count=%i", type, 0);
+#endif
 				break;
 			}
 			/* Enable compression after we have responded with SUCCESS. */
@@ -344,10 +359,20 @@ do_authenticated1(Authctxt *authctxt)
 			break;
 
 		case SSH_CMSG_REQUEST_PTY:
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, 2);
+#endif
+
 			success = session_pty_req(s);
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, success);
+#endif
 			break;
 
 		case SSH_CMSG_X11_REQUEST_FORWARDING:
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, 2);
+#endif
 			s->auth_proto = packet_get_string(&proto_len);
 			s->auth_data = packet_get_string(&data_len);
 
@@ -380,51 +405,103 @@ do_authenticated1(Authctxt *authctxt)
 			break;
 
 		case SSH_CMSG_AGENT_REQUEST_FORWARDING:
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, 2);
+#endif
 			if (!options.allow_agent_forwarding ||
 			    no_agent_forwarding_flag || compat13) {
 				debug("Authentication agent forwarding not permitted for this authentication.");
+#ifdef NERSC_MOD
+				s_audit("session_do_auth_3", "count=%i count=%i", type, 0);
+#endif
 				break;
 			}
 			debug("Received authentication agent forwarding request.");
 			success = auth_input_request_forwarding(s->pw);
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, success);
+#endif
 			break;
 
 		case SSH_CMSG_PORT_FORWARD_REQUEST:
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, 2);
+#endif
 			if (no_port_forwarding_flag) {
+#ifdef NERSC_MOD
+				s_audit("session_do_auth_3", "count=%i count=%i", type, 0);
+#endif
 				debug("Port forwarding not permitted for this authentication.");
 				break;
 			}
 			if (!(options.allow_tcp_forwarding & FORWARD_REMOTE)) {
 				debug("Port forwarding not permitted.");
+#ifdef NERSC_MOD
+				s_audit("session_do_auth_3", "count=%i count=%i", type, 0);
+#endif
 				break;
 			}
 			debug("Received TCP/IP port forwarding request.");
 			if (channel_input_port_forward_request(s->pw->pw_uid == 0,
 			    &options.fwd_opts) < 0) {
 				debug("Port forwarding failed.");
+#ifdef NERSC_MOD
+				s_audit("session_do_auth_3", "count=%i count=%i", type, 0);
+#endif
 				break;
 			}
 			success = 1;
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, 1);
+#endif
 			break;
 
 		case SSH_CMSG_MAX_PACKET_SIZE:
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, 2);
+#endif
 			if (packet_set_maxsize(packet_get_int()) > 0)
 				success = 1;
+#ifdef NERSC_MOD
+			int t_success = 0;
+			if ( success == 1 ) t_success = 1;
+			s_audit("session_do_auth_3", "count=%i count=%i", type, t_success);
+#endif
 			break;
 
 		case SSH_CMSG_EXEC_SHELL:
 		case SSH_CMSG_EXEC_CMD:
+#ifdef NERSC_MOD
+			s_audit("session_do_auth_3", "count=%i count=%i", type, 2);
+			int t_success2 = 1;
+#endif
 			if (type == SSH_CMSG_EXEC_CMD) {
 				command = packet_get_string(&dlen);
 				debug("Exec command '%.500s'", command);
 				if (do_exec(s, command) != 0)
+#ifdef NERSC_MOD
+					{
+					t_success2 = 0;
+					packet_disconnect("command execution failed");
+					}
+#else
 					packet_disconnect(
 					    "command execution failed");
+#endif
+
 				free(command);
 			} else {
 				if (do_exec(s, NULL) != 0)
+#ifdef NERSC_MOD
+					{
+					t_success2 = 0;
+					packet_disconnect("command execution failed");
+					}
+#else
 					packet_disconnect(
 					    "shell execution failed");
+#endif
+
 			}
 			packet_check_eom();
 			session_close(s);
@@ -506,6 +583,16 @@ do_exec_no_pty(Session *s, const char *command)
 	}
 #endif
 
+#ifdef NERSC_MOD
+	if ( command != NULL ) 	{
+
+		char* t1buf = encode_string(command, strlen(command));
+		s_audit("session_remote_exec_no_pty_3", "count=%i count=%i count=%ld uristring=%s", 
+			client_session_id, s->chanid, (long)getppid(), t1buf);
+		free(t1buf);
+	}
+#endif
+
 	session_proctitle(s);
 
 	/* Fork the child. */
@@ -661,6 +748,15 @@ do_exec_pty(Session *s, const char *command)
 	ptyfd = s->ptyfd;
 	ttyfd = s->ttyfd;
 
+#ifdef NERSC_MOD
+	if ( command != NULL ) 	{
+
+		char* t1buf = encode_string(command, strlen(command));
+		s_audit("session_remote_exec_pty_3", "count=%i count=%i count=%ld uristring=%s", 
+			client_session_id, s->chanid, (long)getppid(), t1buf);
+		free(t1buf);
+	}
+#endif
 	/*
 	 * Create another descriptor of the pty master side for use as the
 	 * standard input.  We could use the original descriptor, but this
@@ -807,6 +903,19 @@ do_exec(Session *s, const char *command)
 	const char *forced = NULL, *tty = NULL;
 	char session_type[1024];
 
+#ifdef NERSC_MOD
+	/* since the channel client/server code now takes the raw string
+	 *  data, we remove the 'clean_command' functionality 
+	 */
+	if ( command != NULL ) 	{
+
+		char* t1buf = encode_string(command, strlen(command));
+		s_audit("session_remote_do_exec_3", "count=%i count=%i count=%ld uristring=%s", 
+			client_session_id, s->chanid, (long)getppid(), t1buf);
+		free(t1buf);
+	}
+#endif
+
 	if (options.adm_forced_command) {
 		original_command = command;
 		command = options.adm_forced_command;
@@ -2341,6 +2450,17 @@ session_input_channel_req(Channel *c, const char *rtype)
 			success = session_env_req(s);
 		}
 	}
+
+#ifdef NERSC_MOD
+	if ((strcmp(rtype,"window-change") != 0) && (strcmp(rtype,"env") != 0)) {
+
+		char* t1buf = encode_string(rtype, strlen(rtype));
+		s_audit("session_channel_request_3", "count=%i int=%d count=%d uristring=%s", 
+			client_session_id, getpid(), c->self, t1buf);
+		free(t1buf);
+	}
+#endif
+
 	if (strcmp(rtype, "window-change") == 0) {
 		success = session_window_change_req(s);
 	} else if (strcmp(rtype, "break") == 0) {
@@ -2520,6 +2640,10 @@ session_exit_message(Session *s, int status)
 	/* disconnect channel */
 	debug("session_exit_message: release channel %d", s->chanid);
 
+#ifdef NERSC_MOD
+	s_audit("session_exit_3", "count=%i count=%d count=%ld count=%d", client_session_id, s->chanid, (long)getppid(), status);
+#endif
+
 	/*
 	 * Adjust cleanup callback attachment to send close messages when
 	 * the channel gets EOF. The session will be then be closed
@@ -2734,6 +2858,14 @@ session_setup_x11fwd(Session *s)
 		    s->display_number, s->screen);
 		s->display = xstrdup(display);
 		s->auth_display = xstrdup(auth_display);
+
+#ifdef NERSC_MOD
+		char* t1buf = encode_string(display, strlen(display));
+		s_audit("session_x11fwd_3", "count=%i count=%i uristring=%s", 
+			client_session_id, s->chanid, t1buf);
+		free(t1buf);
+#endif
+
 	} else {
 #ifdef IPADDR_IN_DISPLAY
 		struct hostent *he;
diff --git a/sftp-server.c b/sftp-server.c
index 646286a..32b84db 100644
--- a/sftp-server.c
+++ b/sftp-server.c
@@ -52,6 +52,11 @@
 #include "sftp.h"
 #include "sftp-common.h"
 
+#ifdef NERSC_MOD
+#include "nersc.h"
+extern int client_session_id;
+#endif
+
 /* Our verbosity */
 static LogLevel log_level = SYSLOG_LEVEL_ERROR;
 
@@ -636,6 +641,12 @@ send_statvfs(u_int32_t id, struct statvfs *st)
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 	send_msg(msg);
 	sshbuf_free(msg);
+
+#ifdef NERSC_MOD
+	s_audit("sftp_process_init_3", "count=%i int=%d int=%d",
+		get_client_session_id(), (int)getppid(), version);
+#endif
+
 }
 
 /* parse incoming */
@@ -712,6 +723,14 @@ process_open(u_int32_t id)
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string( name, strlen(name));
+	s_audit("sftp_process_open_3", "count=%i int=%d uristring=%s",
+		get_client_session_id(), (int)getppid(), t1buf);
+	free(t1buf);
+#endif
+
 	free(name);
 }
 
@@ -728,6 +747,11 @@ process_close(u_int32_t id)
 	ret = handle_close(handle);
 	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+
+#ifdef NERSC_MOD
+	s_audit("sftp_process_close_3", "count=%i int=%d int=%d  int=%d", 
+		get_client_session_id(), (int)getppid(), id, handle);
+#endif
 }
 
 static void
@@ -837,6 +861,14 @@ process_do_stat(u_int32_t id, int do_lstat)
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(name, strlen(name));
+	s_audit("sftp_process_do_stat_3", "count=%i int=%d uristring=%s",
+		get_client_session_id(), (int)getppid(), t1buf);
+	free(t1buf);
+#endif
+
 	free(name);
 }
 
@@ -876,6 +908,11 @@ process_fstat(u_int32_t id)
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+
+#ifdef NERSC_MOD
+	s_audit("sftp_process_fstat_3", "count=%i int=%d int=%d", 
+		get_client_session_id(), (int)getppid(), handle);
+#endif
 }
 
 static struct timeval *
@@ -1000,6 +1037,13 @@ process_fsetstat(u_int32_t id)
 		}
 	}
 	send_status(id, status);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string( handle_to_name(handle), strlen(handle_to_name(handle)) );
+	s_audit("sftp_process_fsetstat_3", "count=%i int=%d int=%d uristring=%s", 
+		get_client_session_id(), (int)getppid(), id, t1buf);
+	free(t1buf);
+#endif
 }
 
 static void
@@ -1029,6 +1073,13 @@ process_opendir(u_int32_t id)
 	}
 	if (status != SSH2_FX_OK)
 		send_status(id, status);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(path, strlen(path));
+	s_audit("sftp_process_opendir_3", "count=%i int=%d uristring=%s",
+		get_client_session_id(), (int)getpid(), t1buf);
+	free(t1buf);
+#endif
 	free(path);
 }
 
@@ -1084,6 +1135,12 @@ process_readdir(u_int32_t id)
 		} else {
 			send_status(id, SSH2_FX_EOF);
 		}
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(path, strlen(path));
+	s_audit("sftp_process_readdir_3", "count=%i int=%d uristring=%s",
+		get_client_session_id(), (int)getppid(), t1buf);
+#endif
 		free(stats);
 	}
 }
@@ -1102,6 +1159,12 @@ process_remove(u_int32_t id)
 	r = unlink(name);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(name, strlen(name));
+	s_audit("sftp_process_remove_3", "count=%i int=%d uristring=%s",
+		get_client_session_id(), (int)getppid(), t1buf);
+#endif
 	free(name);
 }
 
@@ -1123,6 +1186,13 @@ process_mkdir(u_int32_t id)
 	r = mkdir(name, mode);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(name, strlen(name));
+	s_audit("sftp_process_mkdir_3", "count=%i int=%d uristring=%s",
+		get_client_session_id(), (int)getpid(), t1buf);
+	free(t1buf);
+#endif
 	free(name);
 }
 
@@ -1140,6 +1210,13 @@ process_rmdir(u_int32_t id)
 	r = rmdir(name);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(name, strlen(name));
+	s_audit("sftp_process_rmdir_3", "count=%i int=%d uristring=%s",
+		get_client_session_id(), (int)getppid(), t1buf);
+	free(t1buf);
+#endif
 	free(name);
 }
 
@@ -1167,6 +1244,13 @@ process_realpath(u_int32_t id)
 		s.name = s.long_name = resolvedname;
 		send_names(id, 1, &s);
 	}
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(path, strlen(path));
+	s_audit("sftp_process_realpath_3", "count=%i int=%d uristring=%s",
+		get_client_session_id(), (int)getppid(), t1buf);
+	free(t1buf);
+#endif
 	free(path);
 }
 
@@ -1226,6 +1310,17 @@ process_rename(u_int32_t id)
 			status = SSH2_FX_OK;
 	}
 	send_status(id, status);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string( oldpath, strlen(oldpath));
+	char* t2buf = encode_string( newpath, strlen(newpath));
+
+	s_audit("sftp_process_rename_3", "count=%i int=%d uristring=%s uristring=%s",
+		get_client_session_id(), (int)getppid(), t1buf, t2buf);
+
+	free(t1buf);
+	free(t2buf);
+#endif
 	free(oldpath);
 	free(newpath);
 }
@@ -1252,6 +1347,13 @@ process_readlink(u_int32_t id)
 		s.name = s.long_name = buf;
 		send_names(id, 1, &s);
 	}
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string( path, strlen(path));
+	s_audit("sftp_process_readlink_3", "count=%i int=%d uristring=%s",
+		get_client_session_id(), (int)getppid(), t1buf);
+	free(t1buf);
+#endif
 	free(path);
 }
 
@@ -1271,6 +1373,17 @@ process_symlink(u_int32_t id)
 	r = symlink(oldpath, newpath);
 	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
 	send_status(id, status);
+
+#ifdef NERSC_MOD
+	char* t1buf = encode_string( oldpath, strlen(oldpath));
+	char* t2buf = encode_string( newpath, strlen(newpath));
+
+	s_audit("sftp_process_symlink_3", "count=%i int=%d uristring=%s uristring=%s",
+		get_client_session_id(), (int)getppid(), t1buf, t2buf);
+
+	free(t1buf);
+	free(t2buf);
+#endif
 	free(oldpath);
 	free(newpath);
 }
@@ -1454,7 +1567,13 @@ process(void)
 			}
 		}
 		if (handlers[i].handler == NULL)
+#ifdef NERSC_MOD
+		s_audit("sftp_process_unknown_3", "count=%i int=%d uristring=%d",
+			get_client_session_id(), (int)getppid(), type);
 			error("Unknown message %u", type);
+#else
+			error("Unknown message %u", type);
+#endif
 	}
 	/* discard the remaining bytes from the current packet */
 	if (buf_len < sshbuf_len(iqueue)) {
@@ -1639,7 +1758,15 @@ sftp_server_main(int argc, char **argv, struct passwd *user_pw)
 		}
 	}
 
+#ifdef NERSC_MOD
+	char* t1buf = encode_string(pw->pw_name, strlen(pw->pw_name));
+	s_audit("sftp_process_init_3", "count=%i int=%d uristring=%s addr=%s", 
+		get_client_session_id(), (int)getppid(), t1buf, client_addr);
+	free(t1buf);
+#endif
+
 	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
+
 	for (;;) {
 		memset(rset, 0, set_size);
 		memset(wset, 0, set_size);
diff --git a/sshd.8 b/sshd.8
index 6c521f2..c1bb64d 100644
--- a/sshd.8
+++ b/sshd.8
@@ -880,6 +880,12 @@ the user's home directory becomes accessible.
 This file should be writable only by the user, and need not be
 readable by anyone else.
 .Pp
+.It Pa /etc/hosts.allow
+.It Pa /etc/hosts.deny
+Access controls that should be enforced by tcp-wrappers are defined here.
+Further details described in
+.Xr hosts_access 5 .
+.Pp
 .It Pa /etc/hosts.equiv
 This file is for host-based authentication (see
 .Xr ssh 1 ) .
@@ -986,6 +992,7 @@ The content of this file is not sensitive; it can be world-readable.
 .Xr ssh-keygen 1 ,
 .Xr ssh-keyscan 1 ,
 .Xr chroot 2 ,
+.Xr hosts_access 5 ,
 .Xr login.conf 5 ,
 .Xr moduli 5 ,
 .Xr sshd_config 5 ,
diff --git a/sshd.c b/sshd.c
index f6235ff..ed436dc 100644
--- a/sshd.c
+++ b/sshd.c
@@ -125,6 +125,13 @@
 #include "version.h"
 #include "ssherr.h"
 
+#ifdef LIBWRAP
+#include <tcpd.h>
+#include <syslog.h>
+int allow_severity;
+int deny_severity;
+#endif /* LIBWRAP */
+
 #ifndef O_NOCTTY
 #define O_NOCTTY	0
 #endif
@@ -135,6 +142,15 @@
 #define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3)
 #define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4)
 
+#ifdef NERSC_MOD
+#include "nersc.h"
+extern char n_ntop[NI_MAXHOST];
+extern char n_port[NI_MAXHOST];
+extern int client_session_id;
+extern char interface_list[256];
+extern int audit_disabled = 0;
+#endif
+
 extern char *__progname;
 
 /* Server configuration options. */
@@ -309,6 +325,20 @@ sighup_handler(int sig)
 static void
 sighup_restart(void)
 {
+
+#ifdef NERSC_MOD
+
+	struct addrinfo *ai;
+	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
+
+	ai = options.listen_addrs;
+	
+	if ( getnameinfo(ai->ai_addr, ai->ai_addrlen,ntop, sizeof(ntop), strport, 
+			sizeof(strport),NI_NUMERICHOST|NI_NUMERICSERV) == 0) {
+		s_audit("sshd_restart_3", "addr=%s  port=%s/tcp", ntop, strport);
+	}
+#endif
+
 	logit("Received SIGHUP; restarting.");
 	platform_pre_restart();
 	close_listen_socks();
@@ -1242,6 +1272,15 @@ server_listen(void)
 			fatal("listen on [%s]:%s: %.100s",
 			    ntop, strport, strerror(errno));
 		logit("Server listening on %s port %s.", ntop, strport);
+
+#ifdef NERSC_MOD
+		/* set using (pid,address,port) */
+		set_server_id(getpid(),ntop,(int)options.ports[0]);
+
+		s_audit("sshd_start_3", "addr=%s port=%s/tcp", ntop, strport);
+		client_session_id=0;
+		set_interface_list();
+#endif
 	}
 	freeaddrinfo(options.listen_addrs);
 
@@ -1256,6 +1295,16 @@ server_listen(void)
 static void
 server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 {
+
+#ifdef NERSC_MOD
+	struct addrinfo *ai;
+	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
+
+	ai = options.listen_addrs;
+	struct timeval l_tv;
+	l_tv.tv_sec = 60;
+	l_tv.tv_usec = 0;
+#endif
 	fd_set *fdset;
 	int i, j, ret, maxfd;
 	int key_used = 0, startups = 0;
@@ -1294,7 +1343,27 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 				FD_SET(startup_pipes[i], fdset);
 
 		/* Wait in select until there is a connection. */
+
+#ifndef NERSC_MOD
 		ret = select(maxfd+1, fdset, NULL, NULL, NULL);
+#endif
+
+#ifdef NERSC_MOD
+
+		/*  If a connection happens, we break from the loop with some ammount of
+		 *  data flagged in the return bits of select.  On error we see ret < 0. 
+		 *
+		 *  This needs to be tested wqith great enthusiasm since there might be corner
+		 *  cases of ret == 0 that I am not aware of
+		 */
+			l_tv.tv_sec = 60;
+			l_tv.tv_usec = 0;
+
+			s_audit("sshd_server_heartbeat_3", "count=%i", ret);
+
+			ret = select(maxfd+1, fdset, NULL, NULL, &l_tv);
+#endif
+
 		if (ret < 0 && errno != EINTR)
 			error("select: %.100s", strerror(errno));
 		if (received_sigterm) {
@@ -1303,6 +1372,13 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 			close_listen_socks();
 			if (options.pid_file != NULL)
 				unlink(options.pid_file);
+
+#ifdef NERSC_MOD
+			if (  getnameinfo(ai->ai_addr, ai->ai_addrlen,ntop, sizeof(ntop), strport,
+					sizeof(strport),NI_NUMERICHOST|NI_NUMERICSERV) == 0) {
+				s_audit("sshd_exit_3", "addr=%s  port=%s/tcp", ntop, strport);
+			}
+#endif
 			exit(received_sigterm == SIGTERM ? 0 : 255);
 		}
 		if (key_used && key_do_regen) {
@@ -1820,6 +1896,20 @@ main(int ac, char **av)
 		exit(1);
 	}
 
+#ifdef NERSC_MOD
+	/* here we are setting the values for the server id which lives in nersc.c */
+	getnameinfo(options.listen_addrs->ai_addr, options.listen_addrs->ai_addrlen,
+		n_ntop, sizeof(n_ntop), n_port,sizeof(n_port),
+		NI_NUMERICHOST|NI_NUMERICSERV); 
+
+	/* To avoid linking issues, we just set a variable here based on the running configuration
+	 *   not my favorite
+	 */
+	if ( options.audit_disabled )
+		audit_disabled = 1;
+
+#endif
+
 	debug("sshd version %s, %s", SSH_VERSION,
 #ifdef WITH_OPENSSL
 	    SSLeay_version(SSLEAY_VERSION)
@@ -2214,9 +2304,44 @@ main(int ac, char **av)
 	 */
 	remote_ip = ssh_remote_ipaddr(ssh);
 
+#ifdef NERSC_MOD
+
+	/* here we were setting client_session_id to the current pid
+	 *  but will now use a positive random number 
+	 *  to use as a tracking id for the remainder of the
+	 *  session.  c_s_i is defined in nersc.c
+	 */
+	client_session_id = abs(arc4random() );
+
+	char* t1buf = encode_string(interface_list, strlen(interface_list));
+
+	s_audit("sshd_connection_start_3", "count=%i uristring=%s addr=%s port=%i/tcp addr=%s port=%s/tcp count=%ld", 
+		client_session_id, interface_list, remote_ip, remote_port, n_ntop, n_port);
+
+	free(t1buf);
+#endif
+
 #ifdef SSH_AUDIT_EVENTS
 	audit_connection_from(remote_ip, remote_port);
 #endif
+#ifdef LIBWRAP
+	allow_severity = options.log_facility|LOG_INFO;
+	deny_severity = options.log_facility|LOG_WARNING;
+	/* Check whether logins are denied from this host. */
+	if (packet_connection_is_on_socket()) {
+		struct request_info req;
+
+		request_init(&req, RQ_DAEMON, __progname, RQ_FILE, sock_in, 0);
+		fromhost(&req);
+
+		if (!hosts_access(&req)) {
+			debug("Connection refused by tcp wrapper");
+			refuse(&req);
+			/* NOTREACHED */
+			fatal("libwrap refuse returns");
+		}
+	}
+#endif /* LIBWRAP */
 
 	/* Log the connection. */
 	laddr = get_local_ipaddr(sock_in);
@@ -2363,6 +2488,10 @@ main(int ac, char **av)
 
 	do_authenticated(authctxt);
 
+#ifdef NERSC_MOD
+	s_audit("sshd_connection_end_3", "count=%i addr=%s port=%i/tcp addr=%s port=%s/tcp",
+		 client_session_id, remote_ip, remote_port, n_ntop, n_port);
+#endif
 	/* The connection has been terminated. */
 	packet_get_bytes(&ibytes, &obytes);
 	verbose("Transferred: sent %llu, received %llu bytes",
@@ -2646,11 +2775,11 @@ do_ssh2_kex(void)
 	struct kex *kex;
 	int r;
 
-	if (options.none_enabled == 1)
-		debug("WARNING: None cipher enabled");
+        if (options.none_enabled == 1)
+                debug ("WARNING: None cipher enabled"); 
 
 	myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(
-	    options.kex_algorithms);
+            options.kex_algorithms);
 	myproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(
 	    options.ciphers);
 	myproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(
diff --git a/sshd_config b/sshd_config
index 456292a..b231da9 100644
--- a/sshd_config
+++ b/sshd_config
@@ -138,6 +138,9 @@ Subsystem	sftp	/usr/libexec/sftp-server
 # allow the use of the none cipher
 #NoneEnabled no
 
+# Disable sshd auditing
+#AuditDisabled no
+
 # Example of overriding settings on a per-user basis
 #Match User anoncvs
 #	X11Forwarding no
diff --git a/version.h b/version.h
index f63674e..805bcd8 100644
--- a/version.h
+++ b/version.h
@@ -5,3 +5,9 @@
 #define SSH_PORTABLE	"p1"
 #define SSH_HPN		"-hpn14v12"
 #define SSH_RELEASE	SSH_VERSION SSH_PORTABLE SSH_HPN
+
+#ifdef NERSC_MOD
+#undef SSH_RELEASE
+#define SSH_AUDITING	"NMOD_3.19"
+#define SSH_RELEASE	SSH_VERSION SSH_PORTABLE SSH_HPN SSH_AUDITING
+#endif /* NERSC_MOD */
